@using MudBlazor
@using System.Globalization

<div class="calendar-modal @(IsVisible ? "show" : "")" @onclick="CloseModal" @onmousedown:stopPropagation="true" role="dialog" aria-labelledby="calendar-title" aria-modal="true">
    <div class="calendar-modal-content" @onclick:stopPropagation="true" @onmousedown:stopPropagation="true">
        <div class="calendar-header">
            <button type="button" class="calendar-close-btn" @onclick="Close" @onclick:preventDefault="true" aria-label="Close calendar">
                <i class="fas fa-times"></i>
            </button>
            <h3 id="calendar-title" class="calendar-title">
                <i class="fas fa-calendar-alt"></i>
                Choose Your Perfect Time
            </h3>
            <p class="calendar-subtitle">Select an available 45-minute slot that works for you</p>
        </div>

        @if (IsLoading)
        {
            <div class="calendar-loading">
                <div class="loading-spinner"></div>
                <p>Loading your available times...</p>
            </div>
        }
        else
        {
            <div class="date-selection-section">
                <div class="calendar-main-content">
                    <div class="date-picker-column">
                        <div class="timezone-display">
                            <i class="fas fa-globe-americas"></i>
                            <span>Times shown in your timezone: <strong>@CurrentTimeZoneDisplay</strong></span>
                        </div>
                        
                        <div class="date-picker-container">
                            <MudDatePicker 
                                Date="selectedDate"
                                DateChanged="OnDateSelected"
                                Label="Select a date"
                                MinDate="@DateTime.Today.AddDays(2)"
                                MaxDate="@DateTime.Today.AddDays(35)"
                                IsDateDisabledFunc="@IsDateDisabled"
                                Class="booking-date-picker"
                                Variant="Variant.Outlined"
                                Color="Color.Primary"
                                HelperText="Dates without available slots are disabled"
                                ReadOnly="@(WindowWidth <= 480)"
                                Editable="@(WindowWidth > 480)" />
                            @if (WindowWidth <= 480)
                            {
                                <small style="color: #666; margin-top: 8px; display: block;">
                                    <i class="fas fa-info-circle"></i> Tap the calendar icon to select a date
                                </small>
                            }
                        </div>
                    </div>
                    
                    <div class="time-slots-column">
                        @if (selectedDate.HasValue)
                        {
                            <div class="time-slots-section">
                                <div class="time-slots-header">
                                    <h4><i class="fas fa-clock"></i> Available Times</h4>
                                    <div class="date-display">
                                        <strong>@selectedDate.Value.ToString("dddd, MMMM dd, yyyy")</strong>
                                        <small style="color: #666; display: block; margin-top: 4px;">
                                            All sessions are 45 minutes long
                                        </small>
                                    </div>
                                </div>
                    
                                @if (IsLoadingSlots)
                                {
                                    <div class="slots-loading">
                                        <div class="loading-content">
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                            <span>Finding available times...</span>
                                            <small>This may take a moment</small>
                                        </div>
                                    </div>
                                }
                                else if (timeSlotsForDate.Any())
                                {
                                    <div class="slots-summary-enhanced">
                                        <div class="summary-info">
                                            <div class="availability-indicator">
                                                @{
                                                    var availableCount = timeSlotsForDate.Count(s => s.Status == "Available");
                                                    var totalCount = timeSlotsForDate.Count;
                                                    var availabilityPercent = totalCount > 0 ? (availableCount * 100) / totalCount : 0;
                                                    
                                                    var morningSlots = timeSlotsForDate.Where(s => s.DateTime.Hour < 12).OrderBy(s => s.DateTime).ToList();
                                                    var afternoonSlots = timeSlotsForDate.Where(s => s.DateTime.Hour >= 12 && s.DateTime.Hour < 17).OrderBy(s => s.DateTime).ToList();
                                                    var eveningSlots = timeSlotsForDate.Where(s => s.DateTime.Hour >= 17).OrderBy(s => s.DateTime).ToList();
                                                }
                                                <div class="availability-bar">
                                                    <div class="availability-fill" style="width: @(availabilityPercent)%"></div>
                                                </div>
                                                <span class="availability-text">
                                                    <strong>@availableCount</strong> of <strong>@totalCount</strong> slots available
                                                </span>
                                            </div>
                                            @if (availableCount > 0)
                                            {
                                                <button type="button" class="smart-suggest-btn" @onclick="SelectBestSlot">
                                                    <i class="fas fa-magic"></i> Suggest Best Time
                                                </button>
                                            }
                                        </div>
                                    </div>

                                    <div class="time-slots-container">
                                        @if (morningSlots.Any())
                                        {
                                            <div class="time-period">
                                                <div class="period-header">
                                                    <i class="fas fa-sun"></i>
                                                    <span>Morning</span>
                                                    <small>(@morningSlots.Count(s => s.IsClickable) available)</small>
                                                </div>
                                                <div class="time-slots-grid">
                                                    @foreach (var slot in morningSlots)
                                                    {
                                                        @RenderTimeSlot(slot)
                                                    }
                                                </div>
                                            </div>
                                        }

                                        @if (afternoonSlots.Any())
                                        {
                                            <div class="time-period">
                                                <div class="period-header">
                                                    <i class="fas fa-sun"></i>
                                                    <span>Afternoon</span>
                                                    <small>(@afternoonSlots.Count(s => s.IsClickable) available)</small>
                                                </div>
                                                <div class="time-slots-grid">
                                                    @foreach (var slot in afternoonSlots)
                                                    {
                                                        @RenderTimeSlot(slot)
                                                    }
                                                </div>
                                            </div>
                                        }

                                        @if (eveningSlots.Any())
                                        {
                                            <div class="time-period">
                                                <div class="period-header">
                                                    <i class="fas fa-moon"></i>
                                                    <span>Evening</span>
                                                    <small>(@eveningSlots.Count(s => s.IsClickable) available)</small>
                                                </div>
                                                <div class="time-slots-grid">
                                                    @foreach (var slot in eveningSlots)
                                                    {
                                                        @RenderTimeSlot(slot)
                                                    }
                                                </div>
                                            </div>
                                        }
                                    </div>

                                    @if (!timeSlotsForDate.Any(s => s.IsClickable))
                                    {
                                        <div class="info-message mt-3">
                                            <i class="fas fa-info-circle text-warning"></i>
                                            <span>All slots on <strong>@selectedDate.Value.ToString("dddd, MMMM dd")</strong> are currently unavailable.</span>
                                            @if (selectedDate.Value.DayOfWeek == DayOfWeek.Saturday || selectedDate.Value.DayOfWeek == DayOfWeek.Sunday)
                                            {
                                                <small class="d-block mt-1 text-muted">Weekend availability may be limited due to admin settings.</small>
                                            }
                                        </div>
                                    }
                                }
                                else
                                {
                                    <div class="no-slots-message-enhanced">
                                        <div class="no-slots-icon">
                                            <i class="fas fa-calendar-times"></i>
                                        </div>
                                        <h5>No Available Times</h5>
                                        <p>All time slots are unavailable for <strong>@selectedDate.Value.ToString("dddd, MMMM dd")</strong>.</p>
                                        @if (selectedDate.Value.DayOfWeek == DayOfWeek.Saturday || selectedDate.Value.DayOfWeek == DayOfWeek.Sunday)
                                        {
                                            <div class="weekend-notice">
                                                <i class="fas fa-info-circle"></i>
                                                <span>Weekend appointments may have limited availability.</span>
                                            </div>
                                        }
                                        <div class="no-slots-actions">
                                            <p>Try selecting another date:</p>
                                            <div class="alternative-dates">
                                                @foreach (var altDate in GetAlternativeDates())
                                                {
                                                    <button type="button" class="alt-date-btn" @onclick="@(() => OnQuickDateSelect(altDate.Date))">
                                                        <span class="alt-date-day">@altDate.Date.ToString("ddd")</span>
                                                        <span class="alt-date-num">@altDate.Date.Day</span>
                                                        <span class="alt-slots">@altDate.AvailableCount slots</span>
                                                    </button>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                }

                                @if (SelectedSlot.HasValue && showSelectionToast)
                                {
                                    <div class="selection-toast @(showSelectionToast ? "show" : "")">
                                        <div class="toast-content">
                                            <div class="toast-icon">
                                                <i class="fas fa-check-circle"></i>
                                            </div>
                                            <div class="toast-message">
                                                <strong>Perfect!</strong>
                                                <span>Your session is booked for @TimeZoneInfo.ConvertTimeFromUtc(SelectedSlot.Value, TimeZoneInfo.FindSystemTimeZoneById(CurrentTimeZoneDisplay)).ToString("dddd, MMM dd 'at' h:mm tt")</span>
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        }
                        else
                        {
                            <div class="no-date-selected">
                                <i class="fas fa-arrow-left"></i>
                                <span>Select a date to see available times</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    [Parameter] public List<DateTime> AvailableSlots { get; set; } = new();
    [Parameter] public List<(DateTimeOffset Start, DateTimeOffset End)> BusyTimes { get; set; } = new();
    [Parameter] public List<UnavailableTime> AdminUnavailabilities { get; set; } = new();
    [Parameter] public DateTime? FirstAvailableDate { get; set; }
    [Parameter] public EventCallback<string> OnSlotSelected { get; set; }
    [Parameter] public string CurrentTimeZoneDisplay { get; set; } = "UTC";
    [Parameter] public EventCallback<CalendarItem> OnEventClick { get; set; }
    
    private bool IsTimeZoneValid { get; set; } = false;
    private bool IsLoading { get; set; } = true;
    private DateTime? SelectedSlot { get; set; }
    private bool showSelectionToast = false;
    
    private DateTime? selectedDate;
    private bool IsLoadingSlots = false;
    private List<TimeSlotInfo> timeSlotsForDate = new();

    public class TimeSlotInfo
    {
        public DateTime DateTime { get; set; }
        public string Status { get; set; } = ""; // Available, Busy, Unavailable
        public string DisplayTime { get; set; } = "";
        public string StatusIcon { get; set; } = "";
        public bool IsClickable => Status == "Available";
    }

    private DateTime InitialDateTime => DateTime.UtcNow.AddDays(2).Date; // Always start 2 days from now
    private int WindowWidth { get; set; } = 1920;

    protected override async Task OnInitializedAsync()
    {
        selectedDate = DateTime.Today.AddDays(2); // Set default selected date
        
        // Don't call LoadSlotsForDate here since parameters aren't set yet
        // Just set loading to false and let OnParametersSetAsync handle the rest
        await Task.Delay(500);
        IsLoading = false;
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        
        // Reset modal state when becoming visible
        if (IsVisible)
        {
            _isClosing = false;
            _lastCloseTime = DateTime.MinValue;
            showSelectionToast = false; // Reset toast state
        }
        
        // Only load slots if the calendar is visible and we have parameters
        if (IsVisible && selectedDate.HasValue && !timeSlotsForDate.Any() && AvailableSlots.Any())
        {
            await LoadSlotsForDate(selectedDate.Value);
        }
    }

    private async Task OnDateSelected(DateTime? date)
    {
        selectedDate = date;
        if (date.HasValue)
        {
            await LoadSlotsForDate(date.Value);
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadSlotsForDate(DateTime date)
    {
        try
        {
            IsLoadingSlots = true;
            await InvokeAsync(StateHasChanged);
            
            await LogService.LogInfo("Calendar.LoadSlotsForDate", $"Loading slots for date: {date:yyyy-MM-dd}");
            
            timeSlotsForDate.Clear();
            
            // Get user timezone info
            var userTimeZone = TimeZoneInfo.FindSystemTimeZoneById(CurrentTimeZoneDisplay);
            var adminTimeZone = TimeZoneInfo.FindSystemTimeZoneById("Europe/London");
            
            await LogService.LogInfo("Calendar.LoadSlotsForDate", $"User selected date: {date:yyyy-MM-dd} in timezone {CurrentTimeZoneDisplay}");
            
            // Find all available slots that, when converted to user timezone, fall on the selected date
            var availableSlotsForThisDate = new List<DateTime>();
            
            foreach (var slotUtc in AvailableSlots)
            {
                // Convert UTC slot to user timezone to see what date it appears on
                var slotInUserTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, userTimeZone);
                
                // If this slot appears on the selected date in user timezone, include it
                if (slotInUserTime.Date == date.Date)
                {
                    availableSlotsForThisDate.Add(slotUtc);
                }
            }
            
            availableSlotsForThisDate = availableSlotsForThisDate.OrderBy(slot => slot).ToList();
                
            await LogService.LogInfo("Calendar.LoadSlotsForDate", $"Found {availableSlotsForThisDate.Count} available slots for user date {date:yyyy-MM-dd}");
            
            if (availableSlotsForThisDate.Any())
            {
                var sampleSlots = availableSlotsForThisDate.Take(3).Select(s => 
                {
                    var userTime = TimeZoneInfo.ConvertTimeFromUtc(s, userTimeZone);
                    return $"{s:HH:mm}UTC→{userTime:HH:mm}";
                }).ToList();
                await LogService.LogInfo("Calendar.LoadSlotsForDate", $"Sample slot conversions: {string.Join(", ", sampleSlots)}");
            }
            
            // Only show slots that exist in AvailableSlots - no custom generation
            foreach (var slotUtc in availableSlotsForThisDate)
            {
                // Convert UTC slot back to user timezone for display
                var slotInUserTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, userTimeZone);
                
                var slotInfo = new TimeSlotInfo
                {
                    DateTime = slotUtc, // Keep UTC for processing
                    DisplayTime = slotInUserTime.ToString("h:mm tt"), // Display in user timezone
                    Status = "Available", // These are pre-filtered available slots
                    StatusIcon = "fas fa-clock text-success"
                };
                
                // Double-check if it's busy (already booked) - just in case
                bool isBusy = BusyTimes.Any(b => 
                    slotUtc >= b.Start.UtcDateTime && 
                    slotUtc < b.End.UtcDateTime);
                
                if (isBusy)
                {
                    slotInfo.Status = "Busy";
                    slotInfo.StatusIcon = "fas fa-ban text-danger";
                }
                else
                {
                    // Double-check admin unavailabilities - just in case
                    bool isAdminUnavailable = AdminUnavailabilities.Any(u =>
                    {
                        if (u.StartTime == null || u.EndTime == null || (u.IsRecurring && !u.DayOfWeek.HasValue) || (!u.IsRecurring && !u.Date.HasValue))
                        {
                            return false;
                        }
                        
                        // Convert slot to admin timezone for comparison
                        var slotInAdminTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, adminTimeZone);
                        var slotStartDate = slotInAdminTime.Date;
                        var slotStartTime = slotInAdminTime.TimeOfDay;
                        
                        if (u.IsRecurring)
                        {
                            return slotInAdminTime.DayOfWeek == u.DayOfWeek!.Value &&
                                slotStartTime >= u.StartTime.Value &&
                                slotStartTime < u.EndTime.Value;
                        }
                        else
                        {
                            var unavailableDate = u.Date!.Value.Date;
                            bool matchesDate = slotStartDate == unavailableDate;
                            bool inTimeRange = slotStartTime >= u.StartTime.Value && slotStartTime < u.EndTime.Value;
                            
                            return matchesDate && inTimeRange;
                        }
                    });
                    
                    if (isAdminUnavailable)
                    {
                        slotInfo.Status = "Unavailable";
                        slotInfo.StatusIcon = "fas fa-times-circle text-warning";
                    }
                }
                
                timeSlotsForDate.Add(slotInfo);
            }
            
            await LogService.LogInfo("Calendar.LoadSlotsForDate", $"Successfully loaded {timeSlotsForDate.Count} slots for {date:yyyy-MM-dd}. Available: {timeSlotsForDate.Count(s => s.Status == "Available")}");
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.LoadSlotsForDate", $"Error loading slots for {date:yyyy-MM-dd}: {ex.Message}");
            timeSlotsForDate = new List<TimeSlotInfo>();
        }
        finally
        {
            IsLoadingSlots = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SelectTimeSlot(TimeSlotInfo slotInfo)
    {
        try
        {
            if (!slotInfo.IsClickable)
            {
                await LogService.LogWarning("Calendar.SelectTimeSlot", $"User tried to select non-clickable slot: {slotInfo.DisplayTime} - Status: {slotInfo.Status}");
                return;
            }
                
            SelectedSlot = slotInfo.DateTime;
            
            await LogService.LogInfo("Calendar.SelectTimeSlot", $"User selected time slot: {slotInfo.DisplayTime} ({slotInfo.DateTime:yyyy-MM-dd HH:mm:ss} UTC)");
            
            // Show selection toast
            showSelectionToast = true;
            await InvokeAsync(StateHasChanged);
            
            // Convert to user's timezone for display and callback
            var userTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(CurrentTimeZoneDisplay);
            var slotInUserTimeZone = TimeZoneInfo.ConvertTimeFromUtc(slotInfo.DateTime, userTimeZoneInfo);
            
            await OnSlotSelected.InvokeAsync(slotInUserTimeZone.ToString("o"));
            
            // Let the parent component handle closing - don't automatically close here. The parent will close when it's ready, avoiding timing conflicts
            await Task.Delay(2000);
            showSelectionToast = false;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.SelectTimeSlot", $"Error selecting time slot {slotInfo.DisplayTime}: {ex.Message}");
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, TimeSlotInfo slotInfo)
    {
        try
        {
            if (e.Key == "Enter" || e.Key == " ")
            {
                await SelectTimeSlot(slotInfo);
            }
            else if (e.Key == "Escape")
            {
                await Close();
            }
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.HandleKeyDown", $"Error handling key down: {ex.Message}");
        }
    }

    private RenderFragment RenderTimeSlot(TimeSlotInfo slot) => builder =>
    {
        var isSelected = SelectedSlot.HasValue && SelectedSlot.Value == slot.DateTime;
        
        builder.OpenElement(0, "button");
        builder.AddAttribute(1, "type", "button");
        builder.AddAttribute(2, "class", $"time-slot-btn {slot.Status.ToLower()} {(isSelected ? "selected" : "")}");
        builder.AddAttribute(3, "onclick", EventCallback.Factory.Create(this, () => SelectTimeSlot(slot)));
        builder.AddAttribute(4, "onkeydown", EventCallback.Factory.Create<KeyboardEventArgs>(this, (e) => HandleKeyDown(e, slot)));
        builder.AddAttribute(5, "disabled", !slot.IsClickable);
        builder.AddAttribute(6, "title", $"{slot.DisplayTime} - {slot.Status}");
        builder.AddAttribute(7, "aria-label", $"Time slot {slot.DisplayTime} - {slot.Status}");
        builder.AddAttribute(8, "aria-pressed", isSelected ? "true" : "false");
        builder.AddAttribute(9, "tabindex", slot.IsClickable ? "0" : "-1");
        
        builder.OpenElement(10, "div");
        builder.AddAttribute(11, "class", "slot-time");
        builder.AddContent(12, slot.DisplayTime);
        builder.CloseElement();
        
        builder.OpenElement(13, "div");
        builder.AddAttribute(14, "class", "slot-status");
        builder.OpenElement(15, "i");
        builder.AddAttribute(16, "class", GetStatusIcon(slot.Status));
        builder.CloseElement();
        builder.OpenElement(17, "span");
        builder.AddContent(18, GetStatusText(slot.Status));
        builder.CloseElement();
        builder.CloseElement();
        
        builder.CloseElement();
    };

    private async Task OnQuickDateSelect(DateTime date)
    {
        try
        {
            await LogService.LogInfo("Calendar.OnQuickDateSelect", $"Quick date selected: {date:yyyy-MM-dd}");
            selectedDate = date;
            await LoadSlotsForDate(date);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.OnQuickDateSelect", $"Error selecting quick date: {ex.Message}");
        }
    }

    private async Task SelectBestSlot()
    {
        try
        {
            // Find the earliest available slot that's not too early or too late
            var availableSlots = timeSlotsForDate.Where(s => s.IsClickable).ToList();
            if (!availableSlots.Any()) return;

            // Prefer times between 4 PM and 20 PM
            var preferredSlots = availableSlots.Where(s => 
            {
                var hour = s.DateTime.Hour;
                return hour >= 16 && hour <= 20;
            }).ToList();

            var bestSlot = preferredSlots.Any() ? preferredSlots.First() : availableSlots.First();
            
            await LogService.LogInfo("Calendar.SelectBestSlot", $"Auto-selected best slot: {bestSlot.DisplayTime}");
            await SelectTimeSlot(bestSlot);
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.SelectBestSlot", $"Error selecting best slot: {ex.Message}");
        }
    }

    public class QuickDateOption
    {
        public DateTime Date { get; set; }
        public int AvailableCount { get; set; }
        public bool HasAvailableSlots => AvailableCount > 0;
    }

    private string GetStatusIcon(string status)
    {
        return status switch
        {
            "Available" => "fas fa-clock text-success",
            "Busy" => "fas fa-ban text-danger",
            "Unavailable" => "fas fa-times-circle text-warning",
            _ => "fas fa-question-circle text-muted"
        };
    }

    private string GetStatusText(string status)
    {
        return status switch
        {
            "Available" => "Available",
            "Busy" => "Booked",
            "Unavailable" => "Not available",
            _ => "Unknown"
        };
    }

    private async Task NavigateToDate(DateTime date)
    {
        try
        {
            await LogService.LogInfo("Calendar.NavigateToDate", $"Navigating to date: {date:yyyy-MM-dd}");
            
            selectedDate = date;
            
            // Force immediate UI update
            await InvokeAsync(StateHasChanged);
            
            // Wait for calendar to fully render before scrolling
            await Task.Delay(800);
            
            // Scroll to working hours
            try
            {
                await JSRuntime.InvokeVoidAsync("scrollCalendarToHour", "calendarEventTarget", 10);
            }
            catch (Exception jsEx)
            {
                await LogService.LogWarning("Calendar.NavigateToDate", $"JS scrollCalendarToHour failed: {jsEx.Message}");
            }
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.NavigateToDate", $"Error navigating to date {date:yyyy-MM-dd}: {ex.Message}");
        }
    }

    private async Task OnQuickDateClick(DateTime date, string label)
    {
        try
        {
            await LogService.LogInfo("Calendar.OnQuickDateClick", $"Quick date clicked: {label} ({date:yyyy-MM-dd})");
            await NavigateToDate(date);
        }
        catch (Exception ex)
        {
            await LogService.LogError("Calendar.OnQuickDateClick", $"Error handling quick date click for {label}: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only run if the calendar is visible
        if (!IsVisible)
            return;

        if (firstRender)
        {
            try
            {
                WindowWidth = await JSRuntime.InvokeAsync<int>("eval", "window.innerWidth");
                StateHasChanged();
            }
            catch
            {
                // Ignore JS errors on first render
            }
        }

        // Skip JS calls if calendar is not visible
        try
        {
            await JSRuntime.InvokeVoidAsync("window.colorCalendarSlots");
            await JSRuntime.InvokeVoidAsync("scrollCalendarToHour", "calendarEventTarget", 10);
            
            // Initialize mobile enhancements if on mobile device
            var viewportInfo = await JSRuntime.InvokeAsync<object>("window.getViewportInfo");
            if (viewportInfo != null)
            {
                await JSRuntime.InvokeVoidAsync("window.initMobileCalendarEnhancements");
            }
        }
        catch (Exception ex)
        {
            await LogService.LogWarning("Calendar.OnAfterRenderAsync", $"JS interop error: {ex.Message}");
        }
    }

    private List<QuickDateOption> GetAlternativeDates()
    {
        try
        {
            var userTimeZone = TimeZoneInfo.FindSystemTimeZoneById(CurrentTimeZoneDisplay);
            var alternatives = new List<QuickDateOption>();
            
            // Get next 5 days with available slots
            var currentCheck = selectedDate?.AddDays(1) ?? DateTime.Today.AddDays(2);
            var maxCheck = DateTime.Today.AddDays(30);
            var found = 0;
            
            while (currentCheck <= maxCheck && found < 3)
            {
                var availableCount = AvailableSlots.Count(slotUtc =>
                {
                    var slotInUserTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, userTimeZone);
                    return slotInUserTime.Date == currentCheck.Date;
                });
                
                if (availableCount > 0)
                {
                    alternatives.Add(new QuickDateOption
                    {
                        Date = currentCheck,
                        AvailableCount = availableCount
                    });
                    found++;
                }
                
                currentCheck = currentCheck.AddDays(1);
            }
            
            return alternatives;
        }
        catch (Exception ex)
        {
            LogService.LogError("Calendar.GetAlternativeDates", $"Error getting alternative dates: {ex.Message}").GetAwaiter().GetResult();
            return new List<QuickDateOption>();
        }
    }

    private DateTime _lastCloseTime = DateTime.MinValue;
    private bool _isClosing = false;

    private async Task Close()
    {
        try
        {
            // Prevent multiple rapid close calls - but be more lenient for reopening
            if (_isClosing || (DateTime.Now - _lastCloseTime).TotalMilliseconds < 300)
            {
                return;
            }
            
            _isClosing = true;
            _lastCloseTime = DateTime.Now;
            
            // Add a small delay to ensure any pending events complete
            await Task.Delay(100);
            
            IsVisible = false;
            SelectedSlot = null;
            showSelectionToast = false;
            
            // Ensure state change is propagated
            await IsVisibleChanged.InvokeAsync(IsVisible);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Log error but don't fail - this prevents modal from getting stuck
            await LogService.LogError("Calendar.Close", $"Error closing calendar: {ex.Message}");
        }
        finally
        {
            // Reset the closing flag more quickly to allow reopening
            await Task.Delay(50);
            _isClosing = false;
        }
    }

    private async Task CloseModal(MouseEventArgs e)
    {
        // Prevent accidental closes during modal opening or if already closing
        if (_isClosing || !IsVisible)
        {
            return;
        }
        
        // Don't close if a slot selection is showing (user might want to see the confirmation)
        if (showSelectionToast)
        {
            return;
        }
        
        // Add a small delay to ensure the modal was actually intended to be closed
        // This prevents accidental closes when the user is still interacting with the calendar
        await Task.Delay(200);
        
        // Double-check that we should still close (user might have moved mouse back to content)
        if (IsVisible && !_isClosing && !showSelectionToast)
        {
            await Close();
        }
    }

    private bool IsDateDisabled(DateTime date)
    {
        // Disable past dates
        if (date.Date < DateTime.Now.Date)
            return true;
            
        // Disable dates that have no available slots
        return !HasAvailableSlots(date);
    }

    private bool HasAvailableSlots(DateTime date)
    {
        try
        {
            // Check if any slots in AvailableSlots exist for this date
            // Use the same logic as LoadSlotsForDate - find UTC slots that appear on this date in user timezone
            var userTimeZone = TimeZoneInfo.FindSystemTimeZoneById(CurrentTimeZoneDisplay);
            
            // Find any UTC slot that, when converted to user timezone, falls on the selected date
            bool hasAvailableSlots = AvailableSlots.Any(slotUtc =>
            {
                var slotInUserTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, userTimeZone);
                return slotInUserTime.Date == date.Date;
            });
            
            // Second check: manually verify if this day should be available based on admin unavailabilities
            // Check if there's a recurring unavailability that covers the entire day for this day of week
            var dayOfWeekUnavailability = AdminUnavailabilities.FirstOrDefault(u => 
                u.IsRecurring && 
                u.DayOfWeek.HasValue && 
                u.StartTime.HasValue && 
                u.EndTime.HasValue &&
                u.StartTime.Value == TimeSpan.Zero && 
                u.EndTime.Value >= new TimeSpan(23, 59, 0) &&
                u.DayOfWeek.Value == date.DayOfWeek);
            
            if (dayOfWeekUnavailability != null)
            {
                hasAvailableSlots = false;
            }
            
            // Third check: check for one-time unavailabilities that cover the entire day
            var specificDateUnavailability = AdminUnavailabilities.FirstOrDefault(u => 
                !u.IsRecurring && 
                u.Date.HasValue && 
                u.StartTime.HasValue && 
                u.EndTime.HasValue &&
                u.StartTime.Value == TimeSpan.Zero && 
                u.EndTime.Value >= new TimeSpan(23, 59, 0) &&
                u.Date.Value.Date == date.Date);
            
            if (specificDateUnavailability != null)
            {
                hasAvailableSlots = false;
            }
            
            return hasAvailableSlots;
        }
        catch (Exception ex)
        {
            LogService.LogError("Calendar.HasAvailableSlots", $"Error checking available slots for {date:yyyy-MM-dd}: {ex.Message}").GetAwaiter().GetResult();
            // If there's an error checking slots, allow the date to be selected
            // This prevents the calendar from breaking if there are timezone issues
            return true;
        }
    }
}
