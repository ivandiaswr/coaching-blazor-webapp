@page "/UserDashboard"
@rendermode InteractiveServer
<MudPopoverProvider/>
<MudSnackbarProvider />
<MudDialogProvider />

@attribute [Authorize(Roles = "User")]
<PageTitle>@pageTitle</PageTitle>

<MudPaper Class="dashboard-welcome" Elevation="1">
    <div class="welcome-header">
        <MudIcon Icon="@Icons.Material.Filled.SentimentSatisfied" Class="welcome-icon" />
        <MudText Typo="Typo.h4" Class="welcome-title">
            Welcome back, @userFullName!
        </MudText>
        <MudText Typo="Typo.subtitle2" Class="welcome-subtitle">
            Your personal transformation journey continues here
        </MudText>
    </div>
    
    @if (UpcomingSessions.Any())
    {
        var nextSession = UpcomingSessions.First();
        <MudAlert Severity="Severity.Success" Variant="Variant.Filled" Class="next-session-alert" Icon="@Icons.Material.Filled.Schedule">
            <MudText Typo="Typo.body1">
                🎯 <strong>Your next breakthrough session</strong> is scheduled for
                <strong>@FormatSessionTime(nextSession.ScheduledAt)</strong>
            </MudText>
            <MudText Typo="Typo.body2" Class="mt-2">
                Get ready to unlock your potential and achieve your goals!
            </MudText>
        </MudAlert>
    }
    else
    {
        <MudText Typo="Typo.subtitle1" Class="mb-2">
            You don’t have any sessions scheduled yet. It’s time to book a moment just for you.
        </MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@(() => selectedTab = 0)" Class="mb-4">
            Book a Session
        </MudButton>
    }

    <MudCard Class="active-bookings-card" Elevation="2">
        <MudCardContent>
            <div class="d-flex align-items-center mb-4">
                <MudIcon Icon="@Icons.Material.Filled.Star" Class="mr-2" Color="Color.Warning" />
                <MudText Typo="Typo.h6">Your Active Bookings</MudText>
            </div>

            @if (activePacks.Any() || activeSubscriptions.Any())
            {
                @foreach (var pack in activePacks)
                {
                    var packOption = BookingOptions.FirstOrDefault(o => o.Type == BookingType.SessionPack && o.PackId == pack.Id);
                    <MudPaper Class="active-booking-item pack-item" Elevation="1">
                        <div class="d-flex align-items-center">
                            <MudIcon Icon="@Icons.Material.Filled.Inventory" Class="booking-icon mr-3" Color="Color.Primary" />
                            <div class="flex-grow-1">
                                <MudText Typo="Typo.subtitle1" Class="mb-1">
                                    <strong>@(packOption?.Title ?? pack.Price?.Name ?? "Session Pack")</strong>
                                </MudText>
                                <MudText Typo="Typo.body2" Color="Color.Inherit">
                                    @(pack.Price?.SessionType.GetDisplayName() ?? "Life Coaching") Sessions
                                </MudText>
                            </div>
                            <MudChip T="string" Class="sessions-remaining-badge" Color="Color.Success" Variant="Variant.Filled">
                                @pack.SessionsRemaining sessions left
                            </MudChip>
                        </div>
                    </MudPaper>
                }

                @foreach (var subscription in activeSubscriptions)
                {
                    var subscriptionOption = BookingOptions.FirstOrDefault(o => o.Type == BookingType.Subscription && !o.RequiresPurchase && o.PlanId == subscription.StripeSubscriptionId);
                    var status = subscriptionStatuses.ContainsKey(subscription.Price?.SessionType ?? SessionType.lifeCoaching) 
                        ? subscriptionStatuses[subscription.Price.SessionType] 
                        : new SubscriptionStatusDto();
                    <MudPaper Class="active-booking-item subscription-item" Elevation="1">
                        <div class="d-flex align-items-center justify-space-between">
                            <div class="d-flex align-items-center flex-grow-1">
                                <MudIcon Icon="@Icons.Material.Filled.Subscriptions" Class="booking-icon mr-3" Color="Color.Success" />
                                <div class="flex-grow-1">
                                    <MudText Typo="Typo.subtitle1" Class="mb-1">
                                        <strong>@(subscriptionOption?.Title ?? subscription.Price?.Name ?? "Active Subscription")</strong>
                                    </MudText>
                                    <MudText Typo="Typo.body2" Color="Color.Inherit">
                                        @(subscription.Price?.SessionType.GetDisplayName() ?? "Life Coaching") Monthly Plan
                                    </MudText>
                                </div>
                            </div>
                            <div class="d-flex align-items-center">
                                <MudChip T="string" Class="sessions-remaining-badge mr-2" Color="Color.Info" Variant="Variant.Filled">
                                    @status.Remaining of @status.MonthlyLimit left
                                </MudChip>
                                <MudButton Variant="Variant.Text" Color="Color.Error" Size="Size.Small" 
                                           OnClick="@(() => OpenCancellationDialog(subscription.StripeSubscriptionId))" 
                                           Class="cancel-sub-btn">
                                    Cancel
                                </MudButton>
                            </div>
                        </div>
                    </MudPaper>
                }
            }
            else
            {
                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-2">
                    No active session pack or subscription. Book a session to get started!
                </MudText>
            }
        </MudCardContent>
    </MudCard>
</MudPaper>

<MudTabs @bind-ActivePanelIndex="selectedTab" Elevation="2" Class="main-tabs" 
        HeaderClass="tabs-header" PanelClass="tab-panel" Color="Color.Primary">
    <MudTabPanel Text="✨ Book Session" Icon="@Icons.Material.Filled.CalendarToday">
        <MudPaper Class="booking-tab-wrapper p-4" Elevation="0">
            <MudGrid GutterSize="24px" Justify="Justify.Center">
                <!-- Booking Options Section -->
                <MudItem xs="12" lg="8">
                    <div class="booking-options-grid">
                        <MudGrid Class="mt-2" GutterSize="20px" Justify="Justify.Center">
                            <MudItem xs="12" sm="6" md="4">
                                <MudStack Spacing="2">
                                    <div class="section-header">
                                        <MudIcon Icon="@Icons.Material.Filled.Person" Class="section-icon" />
                                        <MudText Typo="Typo.h6" Class="section-title">Single Session</MudText>
                                    </div>
                                    @foreach (var option in BookingOptions.Where(o => o.Type == BookingType.SingleSession))
                                    {
                                        var cardStyle = $"cursor:{(option.IsAvailable ? "pointer" : "not-allowed")};opacity:{(option.IsAvailable ? "1" : "0.6")}";
                                        <MudCard 
                                            Class="@($"option-card single-session {(SelectedOption?.Id == option.Id ? "selected" : "")}")"
                                            Style="@cardStyle"
                                            @onclick="() => SelectBookingOption(option)">
                                            <MudCardContent Class="compact-card-content">
                                                <div class="card-header">
                                                    <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="card-type-icon" />
                                                    <div class="card-info">
                                                        <MudText Typo="Typo.subtitle1" Class="card-title">@option.Title</MudText>
                                                        <MudText Typo="Typo.caption" Class="card-subtitle">Perfect for a single breakthrough</MudText>
                                                    </div>
                                                </div>
                                                <div class="card-features">
                                                    <div class="feature-item">
                                                        <MudIcon Icon="@Icons.Material.Filled.AccessTime" Size="Size.Small" />
                                                        <MudText Typo="Typo.body2">45 minutes</MudText>
                                                    </div>
                                                    <div class="feature-item">
                                                        <MudIcon Icon="@Icons.Material.Filled.VideoCall" Size="Size.Small" />
                                                        <MudText Typo="Typo.body2">Online session</MudText>
                                                    </div>
                                                </div>
                                                <div class="card-price">
                                                    <MudText Typo="Typo.h6" Color="Color.Primary">@FormatPrice(option.PriceConverted ?? 0, option.Currency)</MudText>
                                                </div>
                                                @if (!option.IsAvailable && option.RequiresPurchase)
                                                {
                                                    <MudAlert Severity="Severity.Error" Dense="true" Class="mt-2">Unavailable</MudAlert>
                                                }
                                            </MudCardContent>
                                        </MudCard>
                                    }
                                </MudStack>
                            </MudItem>

                            <MudItem xs="12" sm="6" md="4">
                                <MudStack Spacing="2">
                                    <div class="section-header">
                                        <MudIcon Icon="@Icons.Material.Filled.Inventory" Class="section-icon" />
                                        <MudText Typo="Typo.h6" Class="section-title">Session Packs</MudText>
                                    </div>
                                    
                                    @* Show existing packs first (no payment required) *@
                                    @{
                                        var existingPacks = BookingOptions.Where(o => o.Type == BookingType.SessionPack && !o.RequiresPurchase).ToList();
                                        var purchasablePacks = BookingOptions.Where(o => o.Type == BookingType.SessionPack && o.RequiresPurchase).ToList();
                                    }
                                    
                                    @if (existingPacks.Any())
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Success" Class="mb-1">
                                            <MudIcon Icon="Icons.Material.Filled.CheckCircle" Size="Size.Small" Class="mr-1" />
                                            Your Available Packs
                                        </MudText>
                                        @foreach (var option in existingPacks)
                                        {
                                            var cardStyle = $"cursor:{(option.IsAvailable ? "pointer" : "not-allowed")};opacity:{(option.IsAvailable ? "1" : "0.6")}";
                                            <MudCard 
                                                Class="@($"option-card session-pack available-pack {(SelectedOption?.Id == option.Id ? "selected" : "")}")"
                                                Style="@cardStyle"
                                                @onclick="() => SelectBookingOption(option)">
                                                <MudCardContent Class="compact-card-content">
                                                    <div class="card-header">
                                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Class="card-type-icon available-icon" />
                                                        <div class="card-info">
                                                            <MudText Typo="Typo.subtitle1" Class="card-title">@option.Title</MudText>
                                                            <MudText Typo="Typo.caption" Class="card-subtitle available-subtitle">Ready to use</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-features">
                                                        <div class="feature-item">
                                                            <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">@(option.TotalSessions ?? 1) sessions</MudText>
                                                        </div>
                                                        <div class="feature-item">
                                                            <MudIcon Icon="@Icons.Material.Filled.Savings" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">Best value</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-description">
                                                        <MudText Typo="Typo.body2" Class="description-text">@option.Description</MudText>
                                                    </div>
                                                    <MudAlert Severity="Severity.Success" Dense="true" Class="available-alert">
                                                        <MudIcon Icon="Icons.Material.Filled.Star" Size="Size.Small" Class="mr-1" />
                                                        No payment needed
                                                    </MudAlert>
                                                </MudCardContent>
                                            </MudCard>
                                        }
                                    }
                                    
                                    @if (purchasablePacks.Any())
                                    {
                                        @if (existingPacks.Any())
                                        {
                                            <MudDivider Class="my-2" />
                                            <MudText Typo="Typo.caption" Color="Color.Info" Class="mb-1">
                                                <MudIcon Icon="Icons.Material.Filled.ShoppingCart" Size="Size.Small" Class="mr-1" />
                                                Purchase New Pack
                                            </MudText>
                                        }
                                        @foreach (var option in purchasablePacks)
                                        {
                                            var cardStyle = $"cursor:{(option.IsAvailable ? "pointer" : "not-allowed")};opacity:{(option.IsAvailable ? "1" : "0.6")}";
                                            <MudCard 
                                                Class="@($"option-card session-pack purchase-pack {(SelectedOption?.Id == option.Id ? "selected" : "")}")"
                                                Style="@cardStyle"
                                                @onclick="() => SelectBookingOption(option)">
                                                <MudCardContent Class="compact-card-content">
                                                    <div class="card-header">
                                                        <MudIcon Icon="@Icons.Material.Filled.Inventory" Class="card-type-icon" />
                                                        <div class="card-info">
                                                            <MudText Typo="Typo.subtitle1" Class="card-title">@option.Title</MudText>
                                                            <MudText Typo="Typo.caption" Class="card-subtitle">Great value for multiple sessions</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-features">
                                                        <div class="feature-item">
                                                            <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">@(option.TotalSessions ?? 1) sessions</MudText>
                                                        </div>
                                                        <div class="feature-item">
                                                            <MudIcon Icon="@Icons.Material.Filled.TrendingDown" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">Save money</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-description">
                                                        <MudText Typo="Typo.body2" Class="description-text">@option.Description</MudText>
                                                    </div>
                                                    <div class="card-price">
                                                        <MudText Typo="Typo.h6" Color="Color.Primary">@FormatPrice(option.PriceConverted ?? 0, option.Currency)</MudText>
                                                    </div>
                                                    @if (!option.IsAvailable && option.RequiresPurchase)
                                                    {
                                                        <MudAlert Severity="Severity.Error" Dense="true" Class="mt-2">Unavailable</MudAlert>
                                                    }
                                                </MudCardContent>
                                            </MudCard>
                                        }
                                    }
                                    
                                    @if (!existingPacks.Any() && !purchasablePacks.Any())
                                    {
                                        <MudText Typo="Typo.body2" Color="Color.Warning">No pack options available.</MudText>
                                    }
                                </MudStack>
                            </MudItem>

                            <MudItem xs="12" sm="6" md="4">
                                <MudStack Spacing="2">
                                    <div class="section-header">
                                        <MudIcon Icon="@Icons.Material.Filled.Subscriptions" Class="section-icon" />
                                        <MudText Typo="Typo.h6" Class="section-title">Subscriptions</MudText>
                                    </div>
                                    
                                    @* Show existing subscriptions first (no payment required) *@
                                    @{
                                        var existingSubs = BookingOptions.Where(o => o.Type == BookingType.Subscription && !o.RequiresPurchase).ToList();
                                        var purchasableSubs = BookingOptions.Where(o => o.Type == BookingType.Subscription && o.RequiresPurchase && o.PriceConverted.HasValue).ToList();
                                        var highestSubPrice = purchasableSubs.Any() ? purchasableSubs.Max(o => o.PriceConverted ?? 0) : 0;
                                    }
                                    
                                    @if (existingSubs.Any())
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Success" Class="mb-1">
                                            <MudIcon Icon="Icons.Material.Filled.CheckCircle" Size="Size.Small" Class="mr-1" />
                                            Your Active Subscriptions
                                        </MudText>
                                        @foreach (var option in existingSubs)
                                        {
                                            var cardStyle = $"cursor:{(option.IsAvailable ? "pointer" : "not-allowed")};opacity:{(option.IsAvailable ? "1" : "0.6")}";
                                            <MudCard 
                                                Class="@($"option-card subscription available-subscription {(SelectedOption?.Id == option.Id ? "selected" : "")}")"
                                                Style="@cardStyle"
                                                @onclick="() => SelectBookingOption(option)">
                                                <MudCardContent Class="compact-card-content">
                                                    <div class="card-header">
                                                        <MudIcon Icon="Icons.Material.Filled.Star" Size="Size.Medium" Color="Color.Success" />
                                                        <MudText Typo="Typo.h6">@option.Title</MudText>
                                                    </div>
                                                    <div class="card-info">
                                                        <div class="feature-item">
                                                            <MudIcon Icon="Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" />
                                                            <MudText Typo="Typo.caption">Active Plan</MudText>
                                                        </div>
                                                        <div class="feature-item">
                                                            <MudIcon Icon="Icons.Material.Filled.AccessTime" Size="Size.Small" Color="Color.Info" />
                                                            <MudText Typo="Typo.caption">No Payment Required</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-description">
                                                        <MudText Typo="Typo.body2" Class="description-text">@option.Description</MudText>
                                                    </div>
                                                    <MudAlert Severity="Severity.Success" Dense="true" Class="mt-2">Ready to use</MudAlert>
                                                </MudCardContent>
                                            </MudCard>
                                        }
                                    }
                                    
                                    @if (purchasableSubs.Any())
                                    {
                                        @if (existingSubs.Any())
                                        {
                                            <MudDivider Class="my-2" />
                                            <MudText Typo="Typo.caption" Color="Color.Info" Class="mb-1">
                                                <MudIcon Icon="Icons.Material.Filled.ShoppingCart" Size="Size.Small" Class="mr-1" />
                                                Subscribe to New Plan
                                            </MudText>
                                        }
                                        @foreach (var option in purchasableSubs)
                                        {
                                            var isRecommended = (option.PriceConverted ?? 0) == highestSubPrice && highestSubPrice > 0;
                                            var cardStyle = $"cursor:{(option.IsAvailable ? "pointer" : "not-allowed")};opacity:{(option.IsAvailable ? "1" : "0.6")}";
                                            <MudCard 
                                                Class="@($"option-card subscription purchase-subscription {(SelectedOption?.Id == option.Id ? "selected" : "")} {(isRecommended ? "recommended-card" : "")}")"
                                                Style="@($"{cardStyle};position:relative")"
                                                @onclick="() => SelectBookingOption(option)">
                                                <MudCardContent Class="compact-card-content">
                                                    @if (isRecommended)
                                                    {
                                                        <MudChip T="string" Color="Color.Warning" Variant="Variant.Filled" Size="Size.Small" Class="recommended-chip">
                                                            <MudIcon Icon="Icons.Material.Filled.Recommend" Size="Size.Small" Class="mr-1" />
                                                            Recommended
                                                        </MudChip>
                                                    }
                                                    <div class="card-header">
                                                        <MudIcon Icon="Icons.Material.Filled.Subscriptions" Class="card-type-icon" />
                                                        <div class="card-info">
                                                            <MudText Typo="Typo.subtitle1" Class="card-title">@option.Title</MudText>
                                                            <MudText Typo="Typo.caption" Class="card-subtitle">Monthly recurring plan</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-features">
                                                        <div class="feature-item">
                                                            <MudIcon Icon="Icons.Material.Filled.CalendarMonth" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">Monthly Plan</MudText>
                                                        </div>
                                                        <div class="feature-item">
                                                            <MudIcon Icon="Icons.Material.Filled.TrendingUp" Size="Size.Small" />
                                                            <MudText Typo="Typo.body2">Recurring Benefits</MudText>
                                                        </div>
                                                    </div>
                                                    <div class="card-description">
                                                        <MudText Typo="Typo.body2" Class="description-text">@option.Description</MudText>
                                                    </div>
                                                    <div class="card-price">
                                                        <MudText Typo="Typo.h6" Color="Color.Primary">@FormatPrice(option.PriceConverted ?? 0, option.Currency)</MudText>
                                                    </div>
                                                    @if (!option.IsAvailable && option.RequiresPurchase)
                                                    {
                                                        <MudAlert Severity="Severity.Error" Dense="true" Class="mt-2">Unavailable</MudAlert>
                                                    }
                                                </MudCardContent>
                                            </MudCard>
                                        }
                                    }
                                    
                                    @if (!existingSubs.Any() && !purchasableSubs.Any())
                                    {
                                        <MudText Typo="Typo.body2" Color="Color.Warning">No subscription options available.</MudText>
                                    }
                                </MudStack>
                            </MudItem>
                        </MudGrid>
                    </div>
                </MudItem>

                <!-- Booking Form Section -->
                <MudItem xs="12" lg="4">
                    <div class="user-dashboard-request sticky-form">
                        <MudText Typo="Typo.h5" Class="form-title mb-4">
                            <MudIcon Icon="@Icons.Material.Filled.RocketLaunch" Class="mr-2" />
                            Book Your Session
                        </MudText>
                        
                        <MudForm @ref="requestForm" Model="@requestModel">
                            <MudText Typo="Typo.subtitle1"
                                     Class=@($"mb-2 {(showValidationErrors && (SelectedOption == null || string.IsNullOrEmpty(selectedSlotString)) ? "text-red" : "")}")>
                                Selected booking option*
                            </MudText>

                            @if (SelectedOption != null)
                            {
                                var typeClass = SelectedOption.Type switch
                                {
                                    BookingType.SingleSession => "single-session",
                                    BookingType.SessionPack => SelectedOption.RequiresPurchase ? "purchase-pack" : "available-pack",
                                    BookingType.Subscription => SelectedOption.RequiresPurchase ? "purchase-subscription" : "available-subscription",
                                    _ => ""
                                };

                                <MudCard Class="@($"selected-option-card {typeClass} mb-4")" Elevation="2">
                                    <MudCardContent Class="pa-4">
                                        <MudStack Row="true" Spacing="3" AlignItems="AlignItems.Center">
                                            <MudIcon Icon="@GetBookingTypeIcon(SelectedOption.Type)" 
                                                    Size="Size.Large" 
                                                    Color="@GetBookingTypeColor(SelectedOption.Type)"
                                                    Class="selected-option-icon" />
                                            <MudStack Spacing="1" Class="flex-grow-1">
                                                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                                    <MudText Typo="Typo.h6">@SelectedOption.Title</MudText>
                                                    @if (!SelectedOption.RequiresPurchase)
                                                    {
                                                        <MudChip T="string" Size="Size.Small" 
                                                                Color="Color.Success" 
                                                                Variant="Variant.Filled"
                                                                Icon="Icons.Material.Filled.CheckCircle">
                                                            Ready to use
                                                        </MudChip>
                                                    }
                                                </MudStack>
                                                <MudText Typo="Typo.body2" Color="Color.Secondary">@SelectedOption.Description</MudText>
                                                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                                    @if (SelectedOption.PriceConverted.HasValue && SelectedOption.RequiresPurchase)
                                                    {
                                                        <MudText Typo="Typo.subtitle2" Color="Color.Primary">
                                                            <strong>@FormatPrice(SelectedOption.PriceConverted.Value, SelectedOption.Currency)</strong>
                                                            @if (SelectedOption.Type == BookingType.SessionPack && SelectedOption.TotalSessions.HasValue)
                                                            {
                                                                <span> (@SelectedOption.TotalSessions sessions)</span>
                                                            }
                                                            else if (SelectedOption.Type == BookingType.Subscription && SelectedOption.MonthlyLimit.HasValue)
                                                            {
                                                                <span> (@SelectedOption.MonthlyLimit sessions/month)</span>
                                                            }
                                                        </MudText>
                                                    }
                                                    else
                                                    {
                                                        <MudText Typo="Typo.subtitle2" Color="Color.Success">
                                                            <MudIcon Icon="Icons.Material.Filled.Star" Size="Size.Small" Class="mr-1" />
                                                            No payment required
                                                        </MudText>
                                                    }
                                                    <MudChip T="string" Size="Size.Small" 
                                                            Color="Color.Info" 
                                                            Variant="Variant.Text">
                                                        @SelectedOption.Type.GetDisplayName()
                                                    </MudChip>
                                                </MudStack>
                                            </MudStack>
                                        </MudStack>
                                    </MudCardContent>
                                </MudCard>
                            }
                            else
                            {
                                <MudAlert Severity="Severity.Warning" 
                                         Variant="Variant.Outlined" 
                                         Icon="Icons.Material.Filled.Warning"
                                         Class="mb-4 booking-warning">
                                    <MudText Typo="Typo.subtitle2">
                                        <strong>Please select a booking option</strong>
                                    </MudText>
                                    <MudText Typo="Typo.body2" Color="Color.Inherit">
                                        Choose from Single Session, Session Pack, or Subscription to continue.
                                    </MudText>
                                </MudAlert>
                            }

                            <MudSelect Label="Session Category" 
                                       T="SessionType"
                                       Value="requestModel.SessionCategory"
                                       For="@(() => requestModel.SessionCategory)"
                                       ValueChanged="@(value => HandleSessionTypeChange(value))"
                                       Required="true"
                                       RequiredError="Session type is required">
                                @foreach (var type in Enum.GetValues(typeof(SessionType)).Cast<SessionType>())
                                {
                                    <MudSelectItem Value="@type">
                                        @((type.GetType().GetField(type.ToString())?.GetCustomAttributes(typeof(DisplayAttribute), false).FirstOrDefault() as DisplayAttribute)?.Name ?? type.ToString())
                                    </MudSelectItem>
                                }
                            </MudSelect>

                            <MudTextField Label="Message" 
                                          T="string" 
                                          Lines="10" 
                                          @bind-Value="requestModel.Message"
                                          For="@(() => requestModel.Message)"
                                          Required="true"
                                          RequiredError="Message is required" />

                            <MudPaper Class="hoverable-input" @onclick="ToggleCalendar" Style="cursor: pointer;">
                                @if (string.IsNullOrEmpty(selectedSlotString))
                                {
                                    <MudTextField Label="Select Your Preferred Date & Time"
                                                  Value="@("Click here to choose an available time slot")"
                                                  ReadOnly="true"
                                                  Adornment="Adornment.End"
                                                  AdornmentIcon="@Icons.Material.Filled.CalendarMonth"
                                                  InputClass="pointer-cursor"
                                                  Required="true"
                                                  RequiredError="Preferred date and time are required" />
                                }
                                else
                                {
                                    <MudTextField Label="Your Reserved Time Slot"
                                                  Value="@($"✅ Reserved: {selectedSlotString} ({userTimeZone})")"
                                                  ReadOnly="true"
                                                  Adornment="Adornment.End"
                                                  AdornmentIcon="@Icons.Material.Filled.CheckCircle"
                                                  InputClass="pointer-cursor reserved-time-slot"
                                                  HelperText="Click to choose a different time slot"
                                                  Required="true" />
                                }
                            </MudPaper>

                            <Calendar @bind-IsVisible="showSlotCalendar"
                                OnSlotSelected="HandleSlotSelected"
                                CurrentTimeZoneDisplay="@userTimeZone"
                                AvailableSlots="@AvailableSlots"
                                BusyTimes="@BusyTimes"
                                AdminUnavailabilities="@Unavailabilities"
                                FirstAvailableDate="@firstAvailableDate" />

                            <MudButton OnClick="OpenConfirmationDialog" 
                                    Variant="Variant.Filled" 
                                    Color="Color.Primary"
                                    Disabled="@isSubmitting"
                                    Style="font-size: 1.1rem;"
                                    Class="pt-5 pb-4 mt-5">
                                @if (isSubmitting)
                                {
                                    <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                    <span>Processing...</span>
                                }
                                else
                                {
                                    <span>Confirm Information</span>
                                }
                            </MudButton>
                        </MudForm>
                    </div>
                </MudItem>
            </MudGrid>
        </MudPaper>
    </MudTabPanel>

    <MudTabPanel Text="📅 My Sessions" Icon="@Icons.Material.Filled.ListAlt">
        <MudPaper class="sessions-wrapper" Elevation="0">
            <MudStack Row="true" 
                Justify="@Justify.Center" 
                AlignItems="@AlignItems.Center" 
                Spacing="3" 
                Class="session-filters-wrapper mb-5">
                <MudSelect T="string" 
                            Label="Filter" 
                            Value="selectedFilter"
                            ValueChanged="OnFilterChanged"
                            Dense="true">
                    <MudSelectItem Value="@("Upcoming")">Upcoming</MudSelectItem>
                    <MudSelectItem Value="@("Past")">Past</MudSelectItem>
                    <MudSelectItem Value="@("All")">All</MudSelectItem>
                </MudSelect>

                <MudTextField Label="Search"
                                Value="@searchText"
                                ValueChanged="@(EventCallback.Factory.Create<string>(this, OnSearchChanged))"
                                Placeholder="Search by type..."
                                Immediate="true"
                                Adornment="Adornment.Start"
                                AdornmentIcon="@Icons.Material.Filled.Search" />
            </MudStack>

            <MudTable @ref="serverTable"
                        T="VideoSession"
                        Hover="true"
                        Striped="true"
                        Bordered="true"
                        ServerData="@(async (TableState state, CancellationToken cancellationToken) => await LoadServerData(state, CancellationToken.None))">
                <HeaderContent>
                    <MudTh>Date</MudTh>
                    <MudTh>Status</MudTh>
                    <MudTh>Category</MudTh>
                    <MudTh>Session</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@FormatSlotTime(context.ScheduledAt)</MudTd>
                    <MudTd>
                        @if (context.EndedAt.HasValue)
                        {
                            <MudChip T="string" Color="Color.Success">Completed</MudChip>
                        }
                        else if (DateTime.UtcNow < context.ScheduledAt)
                        {
                            <MudChip T="string" Color="Color.Info">Scheduled</MudChip>
                        }
                        else if (DateTime.UtcNow >= context.ScheduledAt && DateTime.UtcNow <= context.ScheduledAt.AddMinutes(45))
                        {
                            <MudChip T="string" Color="Color.Primary">In Progress</MudChip>
                        }
                        else if (context.IsActive == false)
                        {
                            <MudChip T="string" Color="Color.Error">Canceled</MudChip>
                        }
                        else
                        {
                            <MudChip T="string" Color="Color.Warning">Missed</MudChip>
                        }
                    </MudTd>
                    <MudTd>@(context.Session?.SessionCategory.GetDisplayName() ?? "N/A")</MudTd>
                    <MudTd>
                        @if (context.IsActive && !context.EndedAt.HasValue && DateTime.UtcNow >= context.ScheduledAt.AddMinutes(-10) && DateTime.UtcNow <= context.ScheduledAt.AddMinutes(45))
                        {
                            <MudTooltip Text="Join session call">
                                <MudButton Size="Size.Small" OnClick="@(() => JoinSession(context.SessionId))" Color="Color.Primary">
                                    Join Call
                                </MudButton>
                            </MudTooltip>
                        }
                        else if (DateTime.UtcNow > context.ScheduledAt.AddMinutes(45) || context.EndedAt.HasValue)
                        {
                            <MudTooltip Text="View session details">
                                <MudButton Size="Size.Small" OnClick="@(() => OpenSessionDialog(context))" Color="Color.Secondary" Class="p-2">
                                    View Details
                                </MudButton>
                            </MudTooltip>
                        }
                        else if (DateTime.UtcNow >= context.ScheduledAt && DateTime.UtcNow <= context.ScheduledAt.AddMinutes(45))
                        {
                            <MudTooltip Text="View session details">
                                <MudButton Size="Size.Small" OnClick="@(() => OpenSessionDialog(context))" Color="Color.Error">
                                    View Details
                                </MudButton>
                            </MudTooltip>
                        }
                        else if (DateTime.UtcNow < context.ScheduledAt.AddMinutes(-10))
                        {
                            <MudButton Size="Size.Small" OnClick="@(() => OpenSessionDialog(context))" Color="Color.Info" Class="p-2">
                                View Details
                            </MudButton>
                        }
                    </MudTd>
                </RowTemplate>
                <PagerContent>
                    <MudTablePager />
                </PagerContent>
            </MudTable>
        </MudPaper>
    </MudTabPanel>

    <MudTabPanel Text="🤖 Chat with AI Coach" Icon="@Icons.Material.Filled.Chat">
        <MudPaper Class="chat-wrapper" Elevation="0">
            <MudStack Spacing="3">
                <div class="d-flex justify-end">
                    <MudButton OnClick="ClearChat" 
                            Class="clear-chat-button" 
                            StartIcon="@Icons.Material.Filled.Clear" 
                            Size="Size.Small">
                        Clear Chat
                    </MudButton>
                </div>
                <div class="ai-chat-messages" @ref="chatContainer">
                    @foreach (var message in chatMessages)
                    {
                        <MudCard Class="@(message.IsUser ? "user-message" : "bot-message")" AriaLabel="@(message.IsUser ? "User message" : "Bot message")">
                            <MudCardContent Class="d-flex align-center">
                                @if (!message.IsUser)
                                {
                                    <MudAvatar Color="Color.Primary" Size="Size.Small" Class="mr-2">
                                        <MudIcon Icon="@Icons.Material.Filled.SmartToy" />
                                    </MudAvatar>
                                }
                                <div>
                                    <MudText Typo="Typo.body2" Class="message-text">@((MarkupString)message.Text.Replace("\n", "<br>"))</MudText>
                                    @if (message.Resources?.Any() == true)
                                    {
                                        <MudText Typo="Typo.caption">Resources:</MudText>
                                        foreach (var resource in message.Resources)
                                        {
                                            <MudLink Class="d-block" @onclick="@(() => DownloadResource(resource.Url, resource.Name))">
                                                @resource.Name (Download PDF)
                                            </MudLink>
                                        }
                                    }
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-1">
                                        @message.Timestamp.ToString("HH:mm")
                                    </MudText>
                                </div>
                                @if (message.IsUser)
                                {
                                    <MudAvatar Color="Color.Secondary" Size="Size.Small" Class="ml-2">
                                        <MudIcon Icon="@Icons.Material.Filled.Person" />
                                    </MudAvatar>
                                }
                            </MudCardContent>
                        </MudCard>
                    }
                    @if (isSending)
                    {
                        <MudCard Class="bot-message">
                            <MudCardContent Class="d-flex align-center">
                                <MudAvatar Color="Color.Primary" Size="Size.Small" Class="mr-2">
                                    <MudIcon Icon="@Icons.Material.Filled.SmartToy" />
                                </MudAvatar>
                                <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <MudText>Ítala(AI) is typing...</MudText>
                            </MudCardContent>
                        </MudCard>
                    }
                </div>
                <MudForm Class="chat-input-form">
                    <MudTextField InputRef="@chatInputRef"
                                @bind-Value="newMessage" 
                                Placeholder="How can Ítala help you?" 
                                Immediate="true" 
                                OnKeyDown="@(async (KeyboardEventArgs e) => { if (e.Key == "Enter" && !isSending) await SendMessage(); })" 
                                Disabled="isSending" 
                                Variant="Variant.Outlined" 
                                Adornment="Adornment.End" 
                                AdornmentIcon="@Icons.Material.Filled.Send" 
                                AdornmentColor="Color.Primary" 
                                OnAdornmentClick="SendMessage" 
                                Class="chat-input" />
                </MudForm>
            </MudStack>
        </MudPaper>
    </MudTabPanel>
</MudTabs>

<div style="position: fixed; bottom: 22px; right: 22px; z-index: 1000;">
    <a href="https://wa.me/00447732296421"
        target="_blank"
        aria-label="Contact Ítala via WhatsApp"
        title="Need help? Contact me on WhatsApp"
        style="display: flex; align-items: center; justify-content: center; background-color: #25D366; border-radius: 50%; width: 42px; height: 42px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); text-decoration: none;">
        <i class="fa-brands fa-whatsapp" style="color: white; font-size: 24px;"></i>
    </a>
</div>

@code {
    private string pageTitle = "User Dashboard | Ítala Veloso";
    private int selectedTab = 0;
    private List<VideoSession> allSessions = new();
    private IEnumerable<VideoSession> UpcomingSessions => allSessions.Where(s => s.ScheduledAt >= DateTime.UtcNow).OrderBy(s => s.ScheduledAt);
    private string userId = string.Empty;
    private string userFullName = "Guest";

    private MudForm? requestForm;
    private Session requestModel = new();
    private bool showValidationErrors = false;

    private bool showSlotCalendar = false;
    private string? selectedSlotString;
    private List<DateTime> AvailableSlots = new();
    private List<(DateTimeOffset Start, DateTimeOffset End)> BusyTimes = new();
    private List<UnavailableTime> Unavailabilities = new();
    private DateTime? firstAvailableDate;

    private string selectedFilter = "All";
    private string _searchText = string.Empty;
    private string searchText
    {
        get => _searchText;
        set
        {
            if (_searchText != value)
            {
                _searchText = value;
                _ = OnSearchChanged(value);
            }
        }
    }
    private MudTable<VideoSession>? serverTable;

    private List<ChatMessage> chatMessages = new();
    private string newMessage = string.Empty;
    private bool isSending = false;
    private ElementReference chatContainer;
    private ElementReference chatInputRef;

    private BookingType selectedBookingOption = BookingType.SingleSession;
    private bool hasValidPack = false;
    private bool hasActiveSubscription = false;
    private int remainingPackSessions = 0;
    private int remainingSubscriptionSessions = 0;
    private int sessionsUsed = 0;
    private int monthlyLimit = 0;
    private List<BookingOption> BookingOptions = new();
    private BookingOption? SelectedOption = null;

    private IEnumerable<VideoSession> FilteredSessions => allSessions
        .Where(session =>
            (selectedFilter == "Upcoming" && session.ScheduledAt >= DateTime.UtcNow) ||
            (selectedFilter == "Past" && session.ScheduledAt < DateTime.UtcNow) ||
            (selectedFilter == "All"))
        .Where(session => string.IsNullOrWhiteSpace(searchText)
            || session.Session?.SessionCategory.GetDisplayName()?.Contains(searchText, StringComparison.OrdinalIgnoreCase) == true)
        .OrderByDescending(session => session.ScheduledAt);

    private Dictionary<SessionType, SubscriptionStatusDto> subscriptionStatuses = new();
    private List<SessionPack> activePacks = new();
    private List<UserSubscription> activeSubscriptions = new();

    private string userTimeZone = "UTC";
    private string CurrentTimeZoneDisplay = "UTC";
    private string? pendingNavigationUrl;
    private string userCurrency = "GBP";
    private bool isSubmitting = false;
    private bool isCalendarLoading = false;

    protected override async Task OnInitializedAsync()
    {
        var auth = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        userId = auth.User?.Identity?.Name ?? string.Empty;

        try
        {
            var user = await UserManager.FindByEmailAsync(userId);
            if (user != null && !string.IsNullOrWhiteSpace(user.FullName))
            {
                userFullName = user.FullName;
            }
            else
            {
                userFullName = "Guest";
            }

            // Clean up any stale pending sessions for this user
            if (!string.IsNullOrEmpty(userId))
            {
                await LogService.LogInfo("UserDashboard-OnInitialized", $"Cleaning up pending sessions for user: {userId}");
                await SessionService.CleanupPendingSessionsForUserAsync(userId);
            }
        }
        catch (Exception ex)
        {
            await LogService.LogError("LoadFullName Error", ex.Message);
            userFullName = "Guest";
        }

        await LoadSessions();
        await RefreshSessionPackStatus();
        await RefreshSubscriptionStatus();
        // LoadBookingOptions will be called in OnAfterRenderAsync after currency detection
        await LoadAvailableSlots();
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                userTimeZone = await JSRuntime.InvokeAsync<string>("eval", "Intl.DateTimeFormat().resolvedOptions().timeZone");
                try
                {
                    TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
                    await LogService.LogInfo("TimeZoneDetection", $"Detected user time zone: {userTimeZone}");
                    CurrentTimeZoneDisplay = userTimeZone;
                }
                catch (TimeZoneNotFoundException)
                {
                    await LogService.LogWarning("TimeZoneDetection", $"Invalid time zone: {userTimeZone}. Falling back to UTC.");
                    userTimeZone = "UTC";
                    CurrentTimeZoneDisplay = "UTC";
                }
            }
            catch (Exception ex)
            {
                await LogService.LogError("TimeZoneDetection Error", $"Exception: {ex.Message}");
                userTimeZone = "UTC";
                CurrentTimeZoneDisplay = "UTC";
            }

            userCurrency = await DetectUserCurrency();
            await LoadBookingOptions();
            await LoadAvailableSlots();
        }

        var uri = new Uri(NavigationManager.Uri);
        if (uri.AbsolutePath.EndsWith("/payment-success"))
        {
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            var stripeSessionId = query["sessionId"];
            if (!string.IsNullOrEmpty(stripeSessionId))
            {
                try
                {
                    await LogService.LogInfo("OnAfterRenderAsync", $"Processing payment success for StripeSessionId: {stripeSessionId}");
                    
                    var session = await SessionService.GetSessionByStripeSessionIdAsync(stripeSessionId);
                    if (session != null && !session.IsPending && session.IsPaid && session.VideoSession != null)
                    {
                        await LogService.LogInfo("OnAfterRenderAsync", $"Session Id: {session.Id} already confirmed with VideoSession for StripeSessionId: {stripeSessionId}");
                        await RefreshSessionPackStatus();
                        await RefreshSubscriptionStatus();
                        await LoadBookingOptions();
                        await LoadAvailableSlots(); // Refresh slots after confirmation
                        Snackbar.Add("Payment successful! Your session has been scheduled.", Severity.Success);
                        NavigationManager.NavigateTo("/UserDashboard", forceLoad: true);
                        return;
                    }

                    var confirmed = await StripeService.ConfirmPaymentAsync(stripeSessionId);
                    if (!confirmed)
                    {
                        await LogService.LogError("OnAfterRenderAsync", $"Failed to confirm payment for StripeSessionId: {stripeSessionId}");
                        Snackbar.Add("Failed to process payment. Please contact support.", Severity.Error);
                        NavigationManager.NavigateTo("/payment-cancelled", forceLoad: true);
                        return;
                    }

                    await RefreshSessionPackStatus();
                    await RefreshSubscriptionStatus();
                    await LoadBookingOptions();
                    await LoadAvailableSlots(); // Refresh slots after confirmation
                    Snackbar.Add("Payment successful! Your session has been scheduled.", Severity.Success);
                    NavigationManager.NavigateTo("/UserDashboard", forceLoad: true);
                }
                catch (Exception ex)
                {
                    await LogService.LogError("OnAfterRenderAsync", $"Error processing payment: {ex.Message}");
                    Snackbar.Add("An error occurred while processing payment. Please contact support.", Severity.Error);
                }
            }
        }

        if (!string.IsNullOrEmpty(pendingNavigationUrl))
        {
            var url = pendingNavigationUrl;
            pendingNavigationUrl = null;
            NavigationManager.NavigateTo(url, true);
        }
    }

   private async Task RefreshSessionPackStatus()
    {
        try
        {
            remainingPackSessions = await SessionPackService.GetRemainingSessions(userId);
            hasValidPack = remainingPackSessions > 0;
            activePacks = (await SessionPackService.GetUserPacksAsync(userId)).Where(p => p.SessionsRemaining > 0).ToList();
        }
        catch (Exception ex)
        {
            await LogService.LogError("RefreshSessionPackStatus Error", ex.Message);
            Snackbar.Add("Failed to load session pack status.", Severity.Warning);
        }
    }

    private async Task RefreshSubscriptionStatus()
    {
        try
        {
            subscriptionStatuses = await UserSubscriptionService.GetStatusAsync(userId);
            hasActiveSubscription = subscriptionStatuses.Any(s => s.Value.HasActiveSubscription);
            remainingSubscriptionSessions = subscriptionStatuses.Sum(s => s.Value.Remaining);
            sessionsUsed = subscriptionStatuses.Sum(s => s.Value.SessionsUsed);
            monthlyLimit = subscriptionStatuses.Sum(s => s.Value.MonthlyLimit);
            activeSubscriptions = hasActiveSubscription
                ? (await UserSubscriptionService.GetActiveSubscriptionsAsync(userId)).ToList()
                : new List<UserSubscription>();
        }
        catch (Exception ex)
        {
            await LogService.LogError("RefreshSubscriptionStatus Error", ex.Message);
            Snackbar.Add("Failed to load subscription status.", Severity.Warning);
        }
    }

    private async Task OpenCancellationDialog(string subscriptionId)
    {
        var status = subscriptionStatuses.Values.FirstOrDefault(s => s.PlanId == subscriptionId);
        var parameters = new DialogParameters
        {
            { "RemainingSessions", status?.Remaining ?? 0 }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<SubscriptionCancellationDialog>("Confirm Cancellation", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await CancelSubscriptionAsync(subscriptionId);
        }
    }

    private async Task CancelSubscriptionAsync(string subscriptionId)
    {
        try
        {
            var success = await UserSubscriptionService.CancelSubscriptionAsync(userId, subscriptionId);
            if (success)
            {
                await RefreshSubscriptionStatus();
                await LoadBookingOptions();
                Snackbar.Add("Subscription canceled successfully.", Severity.Success);
            }
            else
            {
                Snackbar.Add("Failed to cancel subscription. Please try again or contact support.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            await LogService.LogError("CancelSubscription Error", ex.Message);
            Snackbar.Add("An error occurred while canceling the subscription. Please try again.", Severity.Error);
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task LoadBookingOptions()
    {
        try
        {
            BookingOptions.Clear();
            var sessionType = requestModel.SessionCategory;
            userCurrency = await DetectUserCurrency();

            await LogService.LogInfo("LoadBookingOptions", $"Starting LoadBookingOptions for SessionType: {sessionType}, UserId: {userId}, Currency: {userCurrency}");

            bool usedFallback = false;
            string fallbackCurrency = null;

            var singleSessionPrice = await SessionPriceService.GetPriceForSessionTypeAsync(sessionType);
            if (singleSessionPrice != null)
            {
                var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(singleSessionPrice.PriceGBP, userCurrency);
                var finalCurrency = userCurrency;
                
                if (!string.IsNullOrEmpty(error))
                {
                    finalCurrency = "GBP";
                    convertedPrice = singleSessionPrice.PriceGBP;
                    Snackbar.Add(error, Severity.Warning);
                }
                else if (convertedPrice != singleSessionPrice.PriceGBP && !string.Equals(userCurrency, finalCurrency, StringComparison.OrdinalIgnoreCase))
                {
                    usedFallback = true;
                    fallbackCurrency = userCurrency;
                }

                BookingOptions.Add(new BookingOption
                {
                    Id = Guid.NewGuid().ToString(),
                    Title = $"Single Session ({sessionType.GetDisplayName()})",
                    Description = "Book a one-time session without a subscription or pack.",
                    PriceGBP = singleSessionPrice.PriceGBP,
                    PriceConverted = convertedPrice,
                    Currency = finalCurrency,
                    Type = BookingType.SingleSession,
                    IsAvailable = true,
                    RequiresPurchase = true
                });
            }

            var packPrices = await SessionPackService.GetPricesForSessionTypeAsync(sessionType);
            if (packPrices != null)
            {
                await LogService.LogInfo("LoadBookingOptions", $"Found {packPrices.Count()} pack prices for {sessionType}");
                foreach (var packPrice in packPrices)
                {
                    var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(packPrice.PriceGBP, userCurrency);
                    var finalCurrency = userCurrency;

                    if (!string.IsNullOrEmpty(error))
                    {
                        finalCurrency = "GBP";
                        convertedPrice = packPrice.PriceGBP;
                        Snackbar.Add(error, Severity.Warning);
                    }
                    else if (convertedPrice != packPrice.PriceGBP && !string.Equals(userCurrency, finalCurrency, StringComparison.OrdinalIgnoreCase))
                    {
                        usedFallback = true;
                        fallbackCurrency = userCurrency;
                    }

                    BookingOptions.Add(new BookingOption
                    {
                        Id = Guid.NewGuid().ToString(),
                        Title = packPrice.Name,
                        Description = packPrice.Description ?? $"Includes {packPrice.TotalSessions} sessions.",
                        PriceGBP = packPrice.PriceGBP,
                        PriceConverted = convertedPrice,
                        Currency = finalCurrency,
                        Type = BookingType.SessionPack,
                        TotalSessions = packPrice.TotalSessions,
                        IsAvailable = true,
                        RequiresPurchase = true,
                        PlanId = packPrice.Id.ToString()
                    });
                    await LogService.LogInfo("LoadBookingOptions", $"Added purchasable SessionPack: {packPrice.Name} - {packPrice.PriceGBP} {finalCurrency}");
                }
            }

            var subscriptionPrices = await SubscriptionPriceService.GetPricesForSessionTypeAsync(sessionType);
            if (subscriptionPrices != null)
            {
                await LogService.LogInfo("LoadBookingOptions", $"Found {subscriptionPrices.Count()} subscription prices for {sessionType}");
                foreach (var subscriptionPrice in subscriptionPrices)
                {
                    var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(subscriptionPrice.PriceGBP, userCurrency);
                    var finalCurrency = userCurrency;

                    if (!string.IsNullOrEmpty(error))
                    {
                        finalCurrency = "GBP";
                        convertedPrice = subscriptionPrice.PriceGBP;
                        Snackbar.Add(error, Severity.Warning);
                    }
                    else if (convertedPrice != subscriptionPrice.PriceGBP && !string.Equals(userCurrency, finalCurrency, StringComparison.OrdinalIgnoreCase))
                    {
                        usedFallback = true;
                        fallbackCurrency = userCurrency;
                    }

                    BookingOptions.Add(new BookingOption
                    {
                        Id = Guid.NewGuid().ToString(),
                        Title = subscriptionPrice.Name,
                        Description = subscriptionPrice.Description ?? $"Up to {subscriptionPrice.MonthlyLimit} sessions per month.",
                        PriceGBP = subscriptionPrice.PriceGBP,
                        PriceConverted = convertedPrice,
                        Currency = finalCurrency,
                        Type = BookingType.Subscription,
                        MonthlyLimit = subscriptionPrice.MonthlyLimit,
                        IsAvailable = true,
                        RequiresPurchase = true,
                        PlanId = subscriptionPrice.StripePriceId
                    });
                    await LogService.LogInfo("LoadBookingOptions", $"Added purchasable Subscription: {subscriptionPrice.Name} - {subscriptionPrice.PriceGBP} {finalCurrency}");
                }
            }

            var userPacks = await SessionPackService.GetUserPacksAsync(userId);
            var availablePacks = userPacks.Where(p => p.SessionsRemaining > 0 && p.Price?.SessionType == sessionType).ToList();
            await LogService.LogInfo("LoadBookingOptions", $"Found {availablePacks.Count} available user packs for {sessionType}");
            
            foreach (var pack in availablePacks)
            {
                var price = pack.Price;
                if (price != null)
                {
                    var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(price.PriceGBP, userCurrency);
                    var finalCurrency = userCurrency;

                    if (!string.IsNullOrEmpty(error))
                    {
                        finalCurrency = "GBP";
                        convertedPrice = price.PriceGBP;
                        Snackbar.Add(error, Severity.Warning);
                    }
                    else if (convertedPrice != price.PriceGBP && !string.Equals(userCurrency, finalCurrency, StringComparison.OrdinalIgnoreCase))
                    {
                        usedFallback = true;
                        fallbackCurrency = userCurrency;
                    }

                    var option = new BookingOption
                    {
                        Id = Guid.NewGuid().ToString(),
                        Title = $"Use {price.Name}",
                        Description = $"You have {pack.SessionsRemaining} sessions left.",
                        PriceGBP = price.PriceGBP,
                        PriceConverted = convertedPrice,
                        Currency = finalCurrency,
                        Type = BookingType.SessionPack,
                        PackId = pack.Id,
                        IsAvailable = true,
                        RequiresPurchase = false
                    };
                    BookingOptions.Add(option);
                    await LogService.LogInfo("LoadBookingOptions", $"Added available SessionPack: {price.Name} - {pack.SessionsRemaining} sessions remaining");

                    if (SelectedOption == null)
                    {
                        SelectedOption = option;
                        selectedBookingOption = option.Type;
                    }
                }
            }

            var subscriptions = await UserSubscriptionService.GetActiveSubscriptionsAsync(userId);
            var availableSubscriptions = subscriptions.Where(s => s.Price?.SessionType == sessionType).ToList();
            await LogService.LogInfo("LoadBookingOptions", $"Found {availableSubscriptions.Count} active user subscriptions for {sessionType}");
            
            foreach (var subscription in availableSubscriptions)
            {
                var status = subscriptionStatuses.ContainsKey(sessionType) ? subscriptionStatuses[sessionType] : new SubscriptionStatusDto();
                var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(subscription.Price.PriceGBP, userCurrency);
                var finalCurrency = userCurrency;

                if (!string.IsNullOrEmpty(error))
                {
                    finalCurrency = "GBP";
                    convertedPrice = subscription.Price.PriceGBP;
                    Snackbar.Add(error, Severity.Warning);
                }
                else if (convertedPrice != subscription.Price.PriceGBP && !string.Equals(userCurrency, finalCurrency, StringComparison.OrdinalIgnoreCase))
                {
                    usedFallback = true;
                    fallbackCurrency = userCurrency;
                }

                var option = new BookingOption
                {
                    Id = Guid.NewGuid().ToString(),
                    Title = $"Use {subscription.Price.Name}",
                    Description = $"You’ve used {status.SessionsUsed} of {subscription.Price.MonthlyLimit} sessions this month.",
                    PriceGBP = subscription.Price.PriceGBP,
                    PriceConverted = convertedPrice,
                    Currency = finalCurrency,
                    Type = BookingType.Subscription,
                    IsAvailable = status.Remaining > 0,
                    RequiresPurchase = false,
                    PlanId = subscription.StripeSubscriptionId
                };
                BookingOptions.Add(option);
                await LogService.LogInfo("LoadBookingOptions", $"Added available Subscription: {subscription.Price.Name} - {status.Remaining} sessions remaining this month");

                if (SelectedOption == null && option.IsAvailable)
                {
                    SelectedOption = option;
                    selectedBookingOption = option.Type;
                }
            }

            if (usedFallback && !string.IsNullOrEmpty(fallbackCurrency))
            {
                @* Snackbar.Add($"Prices shown in {fallbackCurrency} using cached rates due to currency conversion service unavailability.", Severity.Info); *@
            }
            
            // Final summary
            var summary = BookingOptions
                .GroupBy(o => o.Type)
                .ToDictionary(g => g.Key, g => new { Total = g.Count(), Available = g.Count(o => !o.RequiresPurchase), Purchasable = g.Count(o => o.RequiresPurchase) });
            
            await LogService.LogInfo("LoadBookingOptions", $"Final BookingOptions summary: " +
                $"SingleSession - Total: {(summary.ContainsKey(BookingType.SingleSession) ? summary[BookingType.SingleSession].Total : 0)} " +
                $"(Available: {(summary.ContainsKey(BookingType.SingleSession) ? summary[BookingType.SingleSession].Available : 0)}, " +
                $"Purchasable: {(summary.ContainsKey(BookingType.SingleSession) ? summary[BookingType.SingleSession].Purchasable : 0)}), " +
                $"SessionPack - Total: {(summary.ContainsKey(BookingType.SessionPack) ? summary[BookingType.SessionPack].Total : 0)} " +
                $"(Available: {(summary.ContainsKey(BookingType.SessionPack) ? summary[BookingType.SessionPack].Available : 0)}, " +
                $"Purchasable: {(summary.ContainsKey(BookingType.SessionPack) ? summary[BookingType.SessionPack].Purchasable : 0)}), " +
                $"Subscription - Total: {(summary.ContainsKey(BookingType.Subscription) ? summary[BookingType.Subscription].Total : 0)} " +
                $"(Available: {(summary.ContainsKey(BookingType.Subscription) ? summary[BookingType.Subscription].Available : 0)}, " +
                $"Purchasable: {(summary.ContainsKey(BookingType.Subscription) ? summary[BookingType.Subscription].Purchasable : 0)})");
                
            await LogService.LogInfo("LoadBookingOptions", $"LoadBookingOptions completed for {sessionType}");

            await LogService.LogInfo("LoadBookingOptions", $"Loaded {BookingOptions.Count} booking options for UserId: {userId}, SessionType: {sessionType}, Currency: {userCurrency}, UsedFallback: {usedFallback}");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogService.LogError("LoadBookingOptions Error", ex.Message);
            Snackbar.Add("Failed to load booking options.", Severity.Warning);
        }
    }

    private string FormatPrice(decimal price, string currency)
    {
        var cultureMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "GBP", "en-GB" }, { "EUR", "fr-FR" }, { "USD", "en-US" }, { "JPY", "ja-JP" },
            { "CAD", "en-CA" }, { "AUD", "en-AU" }, { "BRL", "pt-BR" }, { "MXN", "es-MX" },
            { "CNY", "zh-CN" }, { "HKD", "zh-HK" }, { "SGD", "en-SG" }, { "MYR", "ms-MY" },
            { "THB", "th-TH" }, { "IDR", "id-ID" }, { "PHP", "fil-PH" }, { "AED", "ar-AE" },
            { "SAR", "ar-SA" }, { "INR", "hi-IN" }, { "ZAR", "en-ZA" }, { "NGN", "en-NG" }
        };

        var culture = cultureMap.TryGetValue(currency, out var cultureCode) ? CultureInfo.GetCultureInfo(cultureCode) : CultureInfo.InvariantCulture;
        return price.ToString("C", culture);
    }

    private async Task SelectBookingOption(BookingOption option)
    {
        if (option.IsAvailable)
        {
            SelectedOption = option;
            selectedBookingOption = option.Type;
            StateHasChanged();
        }
    }

    private async Task HandleSessionTypeChange(SessionType newSessionType)
    {
        await LogService.LogInfo("HandleSessionTypeChange", $"Changing session type to {newSessionType}");
        requestModel.SessionCategory = newSessionType;
        SelectedOption = null;
        selectedBookingOption = BookingType.SingleSession;

        var singleSessionPrice = await SessionPriceService.GetPriceForSessionTypeAsync(newSessionType);
        var packPrices = await SessionPackService.GetPricesForSessionTypeAsync(newSessionType);
        var subscriptionPrices = await SubscriptionPriceService.GetPricesForSessionTypeAsync(newSessionType);

        if (singleSessionPrice == null)
        {
            await LogService.LogError("HandleSessionTypeChange", $"No single session price available for {newSessionType.GetDisplayName()}");
            Snackbar.Add($"No single session price available for {newSessionType.GetDisplayName()}. Please select another session type.", Severity.Warning);
            return;
        }

        await LoadBookingOptions();

        if (BookingOptions.Any())
        {
            var preferredOption = BookingOptions.FirstOrDefault(o => !o.RequiresPurchase && o.IsAvailable)
                ?? BookingOptions.FirstOrDefault(o => o.Type == BookingType.SingleSession && o.IsAvailable);
            
            if (preferredOption != null)
            {
                SelectedOption = preferredOption;
                selectedBookingOption = preferredOption.Type;
            }
        }

        StateHasChanged();
    }

    private async Task LoadSessions()
    {
        try
        {
            allSessions = await VideoCallService.GetSessionsForUserAsync(userId);
        }
        catch (Exception ex)
        {
            await LogService.LogError("LoadSessions Error", ex.Message);
            allSessions = new List<VideoSession>();
        }
    }

    private async Task ToggleCalendar()
    {
        if (isCalendarLoading)
            return;

        isCalendarLoading = true;
        showSlotCalendar = !showSlotCalendar;
        if (showSlotCalendar)
        {
            await LoadAvailableSlots();
            await LogService.LogInfo("ToggleCalendar", $"Passing to Calendar: {AvailableSlots.Count} slots, {BusyTimes.Count} busy times, {Unavailabilities.Count} unavailabilities, FirstAvailableDate: {firstAvailableDate?.ToString("yyyy-MM-dd HH:mm UTC") ?? "null"}");
        }
        isCalendarLoading = false;
        StateHasChanged();
    }

    private List<DateTime> GenerateAvailableSlots(DateTime startDate, List<(DateTimeOffset Start, DateTimeOffset End)> busyTimes, List<UnavailableTime> adminUnavailabilities)
    {
        var slots = new List<DateTime>();
        var endDate = startDate.AddDays(25);
        var workStartTime = new TimeSpan(10, 0, 0);
        var workEndTime = new TimeSpan(21, 0, 0);
        var slotDuration = TimeSpan.FromMinutes(45);
        var adminTimeZone = TimeZoneInfo.FindSystemTimeZoneById("Europe/London");

        startDate = startDate.Kind == DateTimeKind.Unspecified ? DateTime.SpecifyKind(startDate, DateTimeKind.Utc) : startDate.ToUniversalTime();

        LogService.LogInfo("GenerateAvailableSlots", $"Processing slots from {startDate:yyyy-MM-dd} to {endDate:yyyy-MM-dd} UTC with {busyTimes.Count} busy times: {string.Join("; ", busyTimes.Select(b => $"{b.Start.UtcDateTime:yyyy-MM-dd HH:mm} to {b.End.UtcDateTime:yyyy-MM-dd HH:mm} UTC"))}");

        for (var date = startDate; date <= endDate; date = date.AddDays(1))
        {
            for (var time = workStartTime; time < workEndTime; time = time.Add(slotDuration))
            {
                var slotStart = date.Date.Add(time);
                var slotEnd = slotStart.Add(slotDuration);

                if (slotStart <= DateTime.UtcNow.AddDays(2))
                {
                    continue;
                }

                bool isBusy = busyTimes.Any(busy =>
                {
                    var busyStart = busy.Start.UtcDateTime;
                    var busyEnd = busy.End.UtcDateTime;
                    bool overlaps = slotStart < busyEnd && slotEnd > busyStart;
                    return overlaps;
                });

                bool isWithinUnavailability = adminUnavailabilities.Any(u =>
                {
                    if (u.StartTime == null || u.EndTime == null || (u.IsRecurring && !u.DayOfWeek.HasValue) || (!u.IsRecurring && !u.Date.HasValue))
                    {
                        LogService.LogWarning("GenerateAvailableSlots", $"Skipping invalid unavailability: ID {u.Id}, IsRecurring: {u.IsRecurring}, DayOfWeek: {u.DayOfWeek}, Date: {u.Date}, StartTime: {u.StartTime}, EndTime: {u.EndTime}");
                        return false;
                    }

                    var slotStartLocal = TimeZoneInfo.ConvertTimeFromUtc(slotStart, adminTimeZone);
                    var slotStartDate = slotStartLocal.Date;
                    var slotStartTime = slotStartLocal.TimeOfDay;

                    if (u.IsRecurring)
                    {
                        return slotStartLocal.DayOfWeek == u.DayOfWeek.Value &&
                            slotStartTime >= u.StartTime.Value &&
                            slotStartTime < u.EndTime.Value;
                    }
                    else
                    {
                        var unavailableDate = u.Date.Value.Date;
                        return slotStartDate == unavailableDate &&
                            slotStartTime >= u.StartTime.Value &&
                            slotStartTime < u.EndTime.Value;
                    }
                });

                if (!isBusy && !isWithinUnavailability)
                {
                    slots.Add(slotStart);
                }
            }
        }

        LogService.LogInfo("GenerateAvailableSlots", $"Generated {slots.Count} available slots from {startDate:yyyy-MM-dd} to {endDate:yyyy-MM-dd} UTC.");
        return slots;
    }

    private async Task LoadAvailableSlots()
    {
        try
        {
            await LogService.LogInfo("LoadAvailableSlots", "Starting slot load...");
            var startDate = DateTime.UtcNow.Date.AddDays(2);
            var endDate = startDate.AddDays(25);
            
            var sessions = await SessionService.GetAllSessionsAsync(false) ?? new List<Session>();
            var relevantSessions = sessions
                .Where(c => c != null && c.PreferredDateTime != default && 
                           c.PreferredDateTime >= startDate && c.PreferredDateTime <= endDate)
                .ToList();
                
            var busyTimes = relevantSessions
                .Select(c => (
                    Start: new DateTimeOffset(c.PreferredDateTime, TimeSpan.Zero),
                    End: new DateTimeOffset(c.PreferredDateTime.AddMinutes(45), TimeSpan.Zero)
                ))
                .ToList();
                
            var adminUnavailabilities = (await UnavailableTimeService.GetAllUnavailableTimesAsync())?.ToList() ?? new List<UnavailableTime>();

            AvailableSlots = GenerateAvailableSlots(startDate, busyTimes, adminUnavailabilities);
            BusyTimes = busyTimes;
            Unavailabilities = adminUnavailabilities;
            firstAvailableDate = AvailableSlots.Any() ? AvailableSlots.Min() : startDate;

            // Debug logging
            await LogService.LogInfo("LoadAvailableSlots", $"Loaded {AvailableSlots.Count} available slots from {relevantSessions.Count} relevant sessions (filtered from {sessions.Count} total). Busy times: {busyTimes.Count}, Unavail: {adminUnavailabilities.Count}.");
            if (AvailableSlots.Any())
            {
                var sampleSlots = AvailableSlots.Take(5).Select(s => s.ToString("yyyy-MM-dd HH:mm UTC")).ToList();
                await LogService.LogInfo("LoadAvailableSlots", $"Sample slots: {string.Join(", ", sampleSlots)}");
                await LogService.LogInfo("LoadAvailableSlots", $"FirstAvailableDate: {firstAvailableDate?.ToString("yyyy-MM-dd HH:mm UTC")}");
            }
        }
        catch (Exception ex)
        {
            await LogService.LogError("LoadAvailableSlots Error", $"Exception: {ex.Message}, StackTrace: {ex.StackTrace}");
            Snackbar.Add("Failed to load available slots.", Severity.Error);
            AvailableSlots = new List<DateTime>();
            BusyTimes = new List<(DateTimeOffset, DateTimeOffset)>();
            Unavailabilities = new List<UnavailableTime>();
        }
        finally
        {
            StateHasChanged();
        }
}

    private string FormatSlotTime(DateTime slotUtc)
    {
        try
        {
            var timeZone = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
            var localTime = TimeZoneInfo.ConvertTimeFromUtc(slotUtc, timeZone);
            return localTime.ToString("ddd, MMM dd, yyyy HH:mm", CultureInfo.InvariantCulture);
        }
        catch
        {
            return slotUtc.ToString("ddd, MMM dd, yyyy HH:mm 'UTC'", CultureInfo.InvariantCulture);
        }
    }

    private string FormatSessionTime(DateTime sessionUtc)
    {
        try
        {
            var timeZone = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
            var localTime = TimeZoneInfo.ConvertTimeFromUtc(sessionUtc, timeZone);
            return localTime.ToString("MMMM dd 'at' HH:mm", CultureInfo.InvariantCulture) + $" ({userTimeZone})";
        }
        catch (Exception ex)
        {
            LogService.LogError("FormatSessionTime", $"Failed to convert UTC time {sessionUtc:yyyy-MM-dd HH:mm:ss} to {userTimeZone}: {ex.Message}");
            return sessionUtc.ToString("MMMM dd 'at' HH:mm 'UTC'", CultureInfo.InvariantCulture);
        }
    }

    private async Task HandleSlotSelected(string isoString)
    {
        try
        {
            await LogService.LogInfo("HandleSlotSelected", $"Received isoString: {isoString}");
            
            var date = DateTime.Parse(isoString);
            await LogService.LogInfo("HandleSlotSelected", $"Parsed date: {date:yyyy-MM-dd HH:mm:ss.fff} (Kind: {date.Kind})");
            
            var userTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
            var utcDate = TimeZoneInfo.ConvertTimeToUtc(date, userTimeZoneInfo);
            await LogService.LogInfo("HandleSlotSelected", $"Converted to UTC: {utcDate:yyyy-MM-dd HH:mm:ss.fff} (Kind: {utcDate.Kind})");
            
            // Log some available slots for comparison
            if (AvailableSlots.Any())
            {
                var nearbySlots = AvailableSlots
                    .Where(s => s.Date == utcDate.Date)
                    .Take(5)
                    .Select(s => s.ToString("yyyy-MM-dd HH:mm:ss.fff"))
                    .ToList();
                await LogService.LogInfo("HandleSlotSelected", $"Available slots on same date: {string.Join(", ", nearbySlots)}");
            }
            
            // Try exact match first
            var exactMatch = AvailableSlots.FirstOrDefault(s => s == utcDate);
            if (exactMatch == default)
            {
                // Try matching with minute precision (ignore seconds/milliseconds)
                var utcDateTruncated = new DateTime(utcDate.Year, utcDate.Month, utcDate.Day, utcDate.Hour, utcDate.Minute, 0, DateTimeKind.Utc);
                exactMatch = AvailableSlots.FirstOrDefault(s => 
                {
                    var slotTruncated = new DateTime(s.Year, s.Month, s.Day, s.Hour, s.Minute, 0, DateTimeKind.Utc);
                    return slotTruncated == utcDateTruncated;
                });
                
                if (exactMatch != default)
                {
                    await LogService.LogInfo("HandleSlotSelected", $"Found match with minute precision: {exactMatch:yyyy-MM-dd HH:mm:ss.fff}");
                    utcDate = exactMatch; // Use the exact slot from AvailableSlots
                }
            }
            
            if (exactMatch == default)
            {
                await LogService.LogWarning("HandleSlotSelected", $"Selected slot {utcDate:yyyy-MM-dd HH:mm:ss.fff} UTC is not in AvailableSlots.");
                Snackbar.Add("Selected time slot is no longer available. Please choose another.", Severity.Warning);
                await LoadAvailableSlots();
                return;
            }

            selectedSlotString = TimeZoneInfo.ConvertTimeFromUtc(utcDate, userTimeZoneInfo).ToString("dd MMM yyyy - HH:mm", CultureInfo.InvariantCulture);
            requestModel.PreferredDateTime = utcDate;
            requestModel.PreferredDateTimeString = isoString;

            await LogService.LogInfo("HandleSlotSelected", $"Generated selectedSlotString: '{selectedSlotString}' from UTC date: {utcDate:yyyy-MM-dd HH:mm:ss.fff}");

            var sessionPrice = await SessionPriceService.GetPriceForSessionTypeAsync(requestModel.SessionCategory);
            var singleSessionOption = BookingOptions.FirstOrDefault(o => o.Type == BookingType.SingleSession);
            if (singleSessionOption != null)
            {
                BookingOptions.Remove(singleSessionOption);
                var (convertedPrice, error) = await CurrencyConversionService.ConvertPrice(sessionPrice.PriceGBP, userCurrency);

                BookingOptions.Add(new BookingOption
                {
                    Id = Guid.NewGuid().ToString(),
                    Title = $"Single Session ({requestModel.SessionCategory.GetDisplayName()})",
                    Description = "Book a one-time session without a subscription or pack.",
                    PriceGBP = sessionPrice.PriceGBP,
                    PriceConverted = convertedPrice,
                    Currency = userCurrency,
                    Type = BookingType.SingleSession,
                    IsAvailable = sessionPrice != null,
                    RequiresPurchase = true
                });
            }

            showSlotCalendar = false;
            await LogService.LogInfo("HandleSlotSelected", $"Successfully selected slot {utcDate:yyyy-MM-dd HH:mm:ss.fff} UTC ({selectedSlotString} {userTimeZone}).");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogService.LogError("HandleSlotSelected Error", ex.Message);
            Snackbar.Add("Failed to select time slot. Please try again.", Severity.Error);
        }
    }

    private async Task OpenConfirmationDialog()
    {
        if (requestForm == null)
        {
            return;
        }

        if (SelectedOption == null)
        {
            Snackbar.Add("Please select a booking option.", Severity.Error);
            showValidationErrors = true;
            return;
        }
        if (string.IsNullOrEmpty(selectedSlotString))
        {
            Snackbar.Add("Please select a preferred date and time.", Severity.Error);
            showValidationErrors = true;
            return;
        }

        await requestForm.Validate();

        if (!requestForm.IsValid)
        {
            return;
        }

        if (SelectedOption == null || string.IsNullOrEmpty(selectedSlotString)) {
            showValidationErrors = true; 
            return;
        }

        var parameters = new DialogParameters
        {
            { "SelectedOption", SelectedOption },
            { "SelectedDateTime", selectedSlotString }
        };

        var options = new DialogOptions 
        { 
            CloseButton = true,
            CloseOnEscapeKey = true, 
            MaxWidth = MaxWidth.Medium, 
            FullWidth = true,
            Position = DialogPosition.Center,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<BookingConfirmationDialog>("Confirm Booking", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await SubmitSessionRequest();
        }
    }

    private async Task SubmitSessionRequest()
    {
        if (isSubmitting)
        {
            await LogService.LogWarning("SubmitSessionRequest", "Submission already in progress.");
            Snackbar.Add("A submission is already in progress. Please wait.", Severity.Warning);
            return;
        }

        isSubmitting = true;
        StateHasChanged();

        try
        {
            await LogService.LogInfo("SubmitSessionRequest", "Starting session request submission");
            
            // Validate required services and dependencies
            if (HttpClient == null)
            {
                await LogService.LogError("SubmitSessionRequest", "HttpClient is null");
                Snackbar.Add("Service configuration error. Please refresh the page and try again.", Severity.Error);
                return;
            }

            if (SelectedOption == null)
            {
                await LogService.LogError("SubmitSessionRequest", "SelectedOption is null");
                Snackbar.Add("Please select a booking option before proceeding.", Severity.Error);
                return;
            }

            var baseUrl = Configuration["AppSettings:BaseUrl"];
            await LogService.LogInfo("SubmitSessionRequest", $"BaseUrl from configuration: '{baseUrl ?? "null"}'");
            
            // Use relative URL if baseUrl is not configured
            var apiEndpoint = string.IsNullOrEmpty(baseUrl) ? "/api/payments/create-checkout-session" : $"{baseUrl}/api/payments/create-checkout-session";
            await LogService.LogInfo("SubmitSessionRequest", $"API endpoint: '{apiEndpoint}'");
            
            // Use the already-parsed DateTime from HandleSlotSelected instead of parsing the formatted string
            if (requestModel.PreferredDateTime == default)
            {
                await LogService.LogError("SubmitSessionRequest", "No preferred date time was set in requestModel");
                Snackbar.Add("Please select a time slot before proceeding.", Severity.Error);
                return;
            }

            var scheduledAtUtc = requestModel.PreferredDateTime;
            await LogService.LogInfo("SubmitSessionRequest", $"Using requestModel.PreferredDateTime: {scheduledAtUtc:yyyy-MM-dd HH:mm:ss} UTC");
            
            // Convert to local time for display purposes only
            var userTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
            var scheduledAtLocal = TimeZoneInfo.ConvertTimeFromUtc(scheduledAtUtc, userTimeZoneInfo);

            await LogService.LogInfo("SubmitSessionRequest", $"Successfully using scheduled date: {scheduledAtLocal:yyyy-MM-dd HH:mm:ss} local time");

            // Validate user authentication
            if (string.IsNullOrEmpty(userId))
            {
                await LogService.LogError("SubmitSessionRequest", "UserId is null or empty");
                Snackbar.Add("User authentication error. Please login and try again.", Severity.Error);
                return;
            }

            var user = await UserManager.FindByEmailAsync(userId);
            if (user == null)
            {
                await LogService.LogError("SubmitSessionRequest", $"User not found in AspNetUsers. Email: {userId}");
                Snackbar.Add("User account not found. Please contact support.", Severity.Error);
                return;
            }

            var conflictingSession = await SessionService.GetAllSessionsAsync(false);
            if (conflictingSession.Any(s => s.PreferredDateTime == scheduledAtUtc && s.IsPaid))
            {
                await LogService.LogWarning("SubmitSessionRequest", $"Slot {scheduledAtUtc:yyyy-MM-dd HH:mm} UTC is already booked.");
                Snackbar.Add("The selected time slot is no longer available. Please choose another.", Severity.Error);
                return;
            }

            var session = new Session
            {
                Id = 0,
                PreferredDateTime = scheduledAtUtc,
                PreferredDateTimeString = requestModel.PreferredDateTimeString,
                SessionCategory = requestModel.SessionCategory,
                Message = requestModel.Message ?? string.Empty,
                Email = userId,
                FirstName = user.FirstName,
                LastName = user.LastName,
                FullName = user.FullName,
                DiscoveryCall = false,
                IsPaid = !SelectedOption.RequiresPurchase,
                PackId = SelectedOption.Type == BookingType.SessionPack && !SelectedOption.RequiresPurchase ? SelectedOption.PackId.ToString() : null
            };

            // Clean up any stale pending sessions before checking
            await SessionService.CleanupPendingSessionsForUserAsync(userId);

            var existingPendingSession = await SessionService.GetPendingSessionByEmailAndPackAsync(
                session.Email, 
                SelectedOption.Type == BookingType.SingleSession ? null : SelectedOption.PlanId ?? SelectedOption.PackId.ToString(),
                requestModel.SessionCategory,
                scheduledAtUtc
            );

            if (existingPendingSession != null)
            {
                await LogService.LogWarning("SubmitSessionRequest", 
                    $"Pending session exists for Email: {session.Email}, SessionId: {existingPendingSession.Id}, SessionCategory: {existingPendingSession.SessionCategory}, PreferredDateTime: {existingPendingSession.PreferredDateTime}");
                Snackbar.Add("A pending session already exists for this time and category. Please complete or cancel the existing payment.", Severity.Warning);
                return;
            }

            await LogService.LogInfo("SubmitSessionRequest", 
                $"Attempting to schedule session at {scheduledAtUtc:yyyy-MM-dd HH:mm} UTC, Type: {SelectedOption.Type}, PlanId: {SelectedOption.PlanId}, PackId: {SelectedOption.PackId}, User: {userId}");

            if (SelectedOption.RequiresPurchase)
                {
                    await LogService.LogInfo("SubmitSessionRequest", 
                        $"Creating pending session for Email: {session.Email}, SessionCategory: {session.SessionCategory}, PreferredDateTime: {scheduledAtUtc}");
                    var createdSession = await SessionService.CreatePendingSessionAsync(session);
                    
                    var checkoutRequest = new CheckoutSessionRequest
                    {
                        Session = createdSession,
                        BookingType = SelectedOption.Type,
                        PlanId = SelectedOption.Type == BookingType.SingleSession ? null : SelectedOption.PlanId,
                        Price = SelectedOption.PriceConverted ?? SelectedOption.PriceGBP ?? 0,
                        Currency = SelectedOption.Currency ?? "GBP",
                        IdempotencyKey = Guid.NewGuid().ToString()
                    };

                    if (SelectedOption.Type != BookingType.SingleSession)
                    {
                        checkoutRequest.Session.PackId = SelectedOption.PlanId;
                    }

                    await LogService.LogInfo("SubmitSessionRequest", 
                        $"Sending checkout request for SessionId: {createdSession.Id}, BookingType: {checkoutRequest.BookingType}, Price: {checkoutRequest.Price}, Currency: {checkoutRequest.Currency}, IdempotencyKey: {checkoutRequest.IdempotencyKey}");
                    
                    try
                    {
                        // Set a timeout for the HTTP request to prevent long waits
                        using var cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(30));
                        
                        var response = await HttpClient.PostAsJsonAsync(apiEndpoint, checkoutRequest, cancellationTokenSource.Token);
                        await LogService.LogInfo("SubmitSessionRequest", $"HTTP Response Status: {response.StatusCode}");
                        
                        if (response.IsSuccessStatusCode)
                        {
                            var data = await response.Content.ReadFromJsonAsync<ModelLayer.Models.DTOs.StripeResponse>(cancellationToken: cancellationTokenSource.Token);
                            if (data != null && !string.IsNullOrEmpty(data.Url))
                            {
                                await LogService.LogInfo("SubmitSessionRequest", $"Stripe checkout URL received: {data.Url}");
                                pendingNavigationUrl = data.Url;
                                NavigationManager.NavigateTo(data.Url, forceLoad: true);
                            }
                            else
                            {
                                await LogService.LogError("SubmitSessionRequest", "Stripe response was null or missing URL");
                                Snackbar.Add("Failed to initiate payment. Please try again.", Severity.Error);
                                if (createdSession.Id != 0)
                                {
                                    SessionService.DeleteSession(createdSession.Id);
                                }
                            }
                        }
                        else
                        {
                            var errorContent = await response.Content.ReadAsStringAsync();
                            await LogService.LogError("SubmitSessionRequest", 
                                $"Checkout failed. Status: {response.StatusCode}, Error: {errorContent}, SessionId: {createdSession.Id}");
                                
                            // Check if this was a timeout error
                            if (response.StatusCode == System.Net.HttpStatusCode.RequestTimeout)
                            {
                                Snackbar.Add("Request timed out. Please check your connection and try again.", Severity.Error);
                            }
                            else
                            {
                                Snackbar.Add("Failed to initiate payment. Please try again.", Severity.Error);
                            }
                            
                            if (createdSession.Id != 0)
                            {
                                SessionService.DeleteSession(createdSession.Id);
                                await LogService.LogInfo("SubmitSessionRequest", 
                                    $"Deleted session with Id: {createdSession.Id} due to checkout failure");
                            }
                        }
                    }
                    catch (HttpRequestException httpEx)
                    {
                        await LogService.LogError("SubmitSessionRequest HttpRequestException", 
                            $"HTTP request failed for SessionId: {createdSession.Id}. Error: {httpEx.Message}, StackTrace: {httpEx.StackTrace}");
                        Snackbar.Add("An error occurred while contacting the payment service.", Severity.Error);
                        if (createdSession.Id != 0)
                        {
                            SessionService.DeleteSession(createdSession.Id);
                            await LogService.LogInfo("SubmitSessionRequest", 
                                $"Deleted session with Id: {createdSession.Id} due to HTTP error");
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        await LogService.LogError("SubmitSessionRequest Timeout", 
                            $"Request timed out for SessionId: {createdSession.Id}");
                        Snackbar.Add("Request timed out. Please check your connection and try again.", Severity.Error);
                        if (createdSession.Id != 0)
                        {
                            SessionService.DeleteSession(createdSession.Id);
                        }
                    }
                    catch (Exception ex)
                    {
                        await LogService.LogError("SubmitSessionRequest HttpClient Error", 
                            $"Failed to send checkout request for SessionId: {createdSession.Id}. Error: {ex.Message}, StackTrace: {ex.StackTrace}");
                        Snackbar.Add("An error occurred while contacting the payment service.", Severity.Error);
                        if (createdSession.Id != 0)
                        {
                            SessionService.DeleteSession(createdSession.Id);
                            await LogService.LogInfo("SubmitSessionRequest", 
                                $"Deleted session with Id: {createdSession.Id} due to client error");
                        }
                    }
                }
            else if (SelectedOption.Type == BookingType.SessionPack)
            {
                if (remainingPackSessions <= 0)
                {
                    await LogService.LogWarning("SubmitSessionRequest", 
                        $"No remaining sessions in pack for User: {userId}, PackId: {SelectedOption.PackId}");
                    Snackbar.Add("No remaining sessions in your pack. Please purchase a new pack or select another option.", Severity.Error);
                    return;
                }

                session.PackId = SelectedOption.PackId.ToString();
                session.IsPaid = true;

                var created = await SessionService.CreateSessionWithPackConsumptionAsync(session, userId, SelectedOption.PackId.ToString(), SessionPackService);
                if (!created)
                {
                    await LogService.LogError("SubmitSessionRequest", 
                        $"Failed to create session with pack consumption for PackId: {SelectedOption.PackId}, User: {userId}");
                    Snackbar.Add("Failed to schedule session. Please try again.", Severity.Error);
                    return;
                }

                await LogService.LogInfo("SubmitSessionRequest", 
                    $"Session scheduled successfully at {scheduledAtUtc:yyyy-MM-dd HH:mm} UTC with PackId: {SelectedOption.PackId}");

                await RefreshSessionPackStatus();
                await LoadBookingOptions();

                var currentPack = activePacks.FirstOrDefault(p => p.Id == SelectedOption.PackId);
                if (currentPack != null && currentPack.SessionsRemaining > 0)
                {
                    SelectedOption = BookingOptions.FirstOrDefault(o => o.Type == BookingType.SessionPack && o.PackId == SelectedOption.PackId);
                }
                else
                {
                    var preferredOption = BookingOptions.FirstOrDefault(o => !o.RequiresPurchase && o.IsAvailable)
                        ?? BookingOptions.FirstOrDefault(o => o.Type == BookingType.SingleSession && o.IsAvailable);
                    SelectedOption = preferredOption;
                    selectedBookingOption = preferredOption?.Type ?? BookingType.SingleSession;
                }

                remainingPackSessions = activePacks.Sum(p => p.SessionsRemaining);
                Snackbar.Add($"Session scheduled! You have {remainingPackSessions} session(s) left in your pack.", Severity.Success);
            }
            else if (SelectedOption.Type == BookingType.Subscription)
            {
                if (remainingSubscriptionSessions <= 0)
                {
                    await LogService.LogWarning("SubmitSessionRequest", 
                        $"No remaining subscription sessions for User: {userId}, PlanId: {SelectedOption.PlanId}");
                    Snackbar.Add("Monthly session limit reached. Please select another option or wait until next month.", Severity.Error);
                    return;
                }

                session.PackId = SelectedOption.PlanId;
                session.IsPaid = true;

                var success = await UserSubscriptionService.RegisterMonthlyUsage(userId, SelectedOption.PlanId);
                if (!success)
                {
                    await LogService.LogError("SubmitSessionRequest", 
                        $"Failed to register monthly usage for PlanId: {SelectedOption.PlanId}, User: {userId}");
                    Snackbar.Add("Failed to register session usage. Monthly limit may have been reached.", Severity.Error);
                    return;
                }

                var created = await SessionService.CreateSessionAsync(session);
                if (!created)
                {
                    await LogService.LogError("SubmitSessionRequest", 
                        $"Failed to create session for PlanId: {SelectedOption.PlanId}, User: {userId}");
                    Snackbar.Add("Failed to schedule session. Please try again.", Severity.Error);
                    return;
                }

                await LogService.LogInfo("SubmitSessionRequest", 
                    $"Session scheduled successfully at {scheduledAtUtc:yyyy-MM-dd HH:mm} UTC with PlanId: {SelectedOption.PlanId}");

                await RefreshSubscriptionStatus();
                await LoadBookingOptions();

                var status = subscriptionStatuses.ContainsKey(requestModel.SessionCategory) ? subscriptionStatuses[requestModel.SessionCategory] : new SubscriptionStatusDto();
                if (status.Remaining > 0)
                {
                    SelectedOption = BookingOptions.FirstOrDefault(o => o.Type == BookingType.Subscription && o.PlanId == SelectedOption.PlanId);
                }
                else
                {
                    var preferredOption = BookingOptions.FirstOrDefault(o => !o.RequiresPurchase && o.IsAvailable)
                        ?? BookingOptions.FirstOrDefault(o => o.Type == BookingType.SingleSession && o.IsAvailable);
                    SelectedOption = preferredOption;
                    selectedBookingOption = preferredOption?.Type ?? BookingType.SingleSession;
                }

                remainingSubscriptionSessions = subscriptionStatuses.Sum(s => s.Value.Remaining);
                Snackbar.Add($"Session scheduled! You have {remainingSubscriptionSessions} session(s) left this month.", Severity.Success);
            }
            else
            {
                await LogService.LogError("SubmitSessionRequest", $"Invalid booking option: {SelectedOption.Type}, User: {userId}");
                Snackbar.Add("Invalid booking option selected.", Severity.Error);
                return;
            }

            // Reset form
            selectedSlotString = null;
            requestModel.Message = string.Empty;
            requestModel.SessionCategory = SessionType.lifeCoaching;
            showSlotCalendar = false;
            await LoadSessions();
            await LoadAvailableSlots();
        }
        catch (Exception ex)
        {
            await LogService.LogError("SubmitSessionRequest", $"Error scheduling session: {ex.Message}");
            Snackbar.Add("An error occurred while scheduling the session. Please try again.", Severity.Error);
        }
        finally
        {
            isSubmitting = false;
            StateHasChanged();
        }
    }

    private async Task<string> DetectUserCurrency()
    {
        try
        {
            var timeZone = await JSRuntime.InvokeAsync<string>("eval", "Intl.DateTimeFormat().resolvedOptions().timeZone");
            var currency = MapTimeZoneToCurrency(timeZone);

            if (IsStripeSupportedCurrency(currency))
            {
                await LogService.LogInfo("DetectUserCurrency", $"Detected currency: {currency} for time zone: {timeZone}");
                return currency;
            }
            else
            {
                await LogService.LogWarning("DetectUserCurrency", $"Unsupported currency {currency} detected for time zone: {timeZone}. Falling back to GBP.");
                Snackbar.Add("Your local currency is not supported. Prices will be shown in GBP.", Severity.Info);
                return "GBP";
            }

            return "GBP";
        }
        catch (Exception ex)
        {
            await LogService.LogError("DetectUserCurrency Error", ex.Message);
            return "GBP";
        }
    }

    private string MapTimeZoneToCurrency(string timeZone)
    {
        var currencyMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            // North America
            { "America/New_York", "USD" },
            { "America/Chicago", "USD" },
            { "America/Denver", "USD" },
            { "America/Los_Angeles", "USD" },
            { "America/Anchorage", "USD" },
            { "America/Honolulu", "USD" },
            { "America/Toronto", "CAD" },
            { "America/Vancouver", "CAD" },
            { "America/Mexico_City", "MXN" },
            { "America/Havana", "CUP" },
            { "America/Jamaica", "JMD" },

            // South America
            { "America/Sao_Paulo", "BRL" },
            { "America/Buenos_Aires", "ARS" },
            { "America/Santiago", "CLP" },
            { "America/Bogota", "COP" },
            { "America/Lima", "PEN" },
            { "America/Caracas", "VES" },

            // Europe
            { "Europe/London", "GBP" },
            { "Europe/Dublin", "EUR" },
            { "Europe/Paris", "EUR" },
            { "Europe/Berlin", "EUR" },
            { "Europe/Amsterdam", "EUR" },
            { "Europe/Brussels", "EUR" },
            { "Europe/Madrid", "EUR" },
            { "Europe/Rome", "EUR" },
            { "Europe/Lisbon", "EUR" },
            { "Europe/Athens", "EUR" },
            { "Europe/Helsinki", "EUR" },
            { "Europe/Stockholm", "SEK" },
            { "Europe/Oslo", "NOK" },
            { "Europe/Copenhagen", "DKK" },
            { "Europe/Warsaw", "PLN" },
            { "Europe/Prague", "CZK" },
            { "Europe/Budapest", "HUF" },
            { "Europe/Moscow", "RUB" },
            { "Europe/Istanbul", "TRY" },
            { "Europe/Kiev", "UAH" },

            // Africa
            { "Africa/Johannesburg", "ZAR" },
            { "Africa/Lagos", "NGN" },
            { "Africa/Cairo", "EGP" },
            { "Africa/Nairobi", "KES" },
            { "Africa/Algiers", "DZD" },
            { "Africa/Accra", "GHS" },

            // Asia
            { "Asia/Tokyo", "JPY" },
            { "Asia/Seoul", "KRW" },
            { "Asia/Shanghai", "CNY" },
            { "Asia/Hong_Kong", "HKD" },
            { "Asia/Singapore", "SGD" },
            { "Asia/Kuala_Lumpur", "MYR" },
            { "Asia/Bangkok", "THB" },
            { "Asia/Jakarta", "IDR" },
            { "Asia/Manila", "PHP" },
            { "Asia/Ho_Chi_Minh", "VND" },
            { "Asia/Dubai", "AED" },
            { "Asia/Riyadh", "SAR" },
            { "Asia/Tehran", "IRR" },
            { "Asia/Karachi", "PKR" },
            { "Asia/Kolkata", "INR" },
            { "Asia/Kathmandu", "NPR" },
            { "Asia/Dhaka", "BDT" },
            { "Asia/Colombo", "LKR" },

            // Australia and Oceania
            { "Australia/Sydney", "AUD" },
            { "Australia/Melbourne", "AUD" },
            { "Australia/Perth", "AUD" },
            { "Australia/Auckland", "NZD" },
            { "Pacific/Fiji", "FJD" },
            { "Pacific/Guam", "USD" },
            { "Pacific/Port_Moresby", "PGK" },

            // Others
            { "Atlantic/Reykjavik", "ISK" },
            { "Pacific/Tahiti", "XPF" },
            { "Antarctica/McMurdo", "NZD" },
        };

        return currencyMap.TryGetValue(timeZone, out var currency) ? currency : "GBP";
    }

    private bool IsStripeSupportedCurrency(string currency)
    {
        var supportedCurrencies = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN",
            "BHD", "BIF", "BMD", "BND", "BOB", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHF",
            "CLP", "CNY", "COP", "CRC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB",
            "EUR", "FJD", "FKP", "FOK", "GBP", "GEL", "GGP", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD",
            "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "IMP", "INR", "IQD", "IRR", "ISK", "JEP", "JMD", "JOD",
            "JPY", "KES", "KGS", "KHR", "KID", "KMF", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD",
            "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN",
            "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR",
            "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP",
            "SLE", "SOS", "SRD", "SSP", "STN", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD",
            "TVD", "TWD", "TZS", "UAH", "UGX", "USD", "UYU", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XCD",
            "XOF", "XPF", "YER", "ZAR", "ZMW"
        };

        return supportedCurrencies.Contains(currency.ToUpper());
    }

    private async Task OpenSessionDialog(VideoSession session)
    {
        var parameters = new DialogParameters
        {
            { "VideoSession", session }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        await DialogService.ShowAsync<UserSessionDialog>("Session Details", parameters, options);
    }

    private void JoinSession(string sessionId)
    {
        var session = allSessions.FirstOrDefault(s => s.SessionId == sessionId);
        if (session == null)
        {
            Snackbar.Add("Session not found.", Severity.Error);
            return;
        }

        var now = DateTime.UtcNow;
        var sessionStart = session.ScheduledAt;
        var sessionEnd = sessionStart.AddMinutes(45);
        var joinWindowStart = sessionStart.AddMinutes(-15);

        if (now < joinWindowStart)
        {
            try
            {
                var userTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
                var joinWindowStartLocal = TimeZoneInfo.ConvertTimeFromUtc(joinWindowStart, userTimeZoneInfo);
                Snackbar.Add($"The session hasn't started yet. Please try again after {joinWindowStartLocal:dd MMM yyyy HH:mm} ({userTimeZone}).", Severity.Warning);
            }
            catch (TimeZoneNotFoundException)
            {
                Snackbar.Add($"The session hasn't started yet. Please try again after {joinWindowStart:dd MMM yyyy HH:mm} UTC.", Severity.Warning);
            }
            return;
        }

        if (now > sessionEnd)
        {
            Snackbar.Add("This session has ended.", Severity.Error);
            return;
        }

        NavigationManager.NavigateTo($"/session/{sessionId}");
    }

    private void HandleCalendarClick(CalendarItem item)
    {
        var session = UpcomingSessions.FirstOrDefault(s => s.ScheduledAt == item.Start);
        if (session == null)
        {
            Snackbar.Add("Session not found.", Severity.Error);
            return;
        }

        var now = DateTime.UtcNow;
        var sessionStart = session.ScheduledAt;
        var sessionEnd = sessionStart.AddMinutes(45);
        var joinWindowStart = sessionStart.AddMinutes(-15);

        if (!session.IsActive)
        {
            Snackbar.Add("This session is no longer active.", Severity.Error);
            return;
        }

        if (now < joinWindowStart)
        {
            try
            {
                var userTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(userTimeZone);
                var joinWindowStartLocal = TimeZoneInfo.ConvertTimeFromUtc(joinWindowStart, userTimeZoneInfo);
                Snackbar.Add($"The session hasn't started yet. Please try again after {joinWindowStartLocal:dd MMM yyyy HH:mm} ({userTimeZone}).", Severity.Warning);
            }
            catch (TimeZoneNotFoundException)
            {
                Snackbar.Add($"The session hasn't started yet. Please try again after {joinWindowStart:dd MMM yyyy HH:mm} UTC.", Severity.Warning);
            }
            return;
        }

        if (now > sessionEnd)
        {
            Snackbar.Add("This session has ended.", Severity.Error);
            return;
        }

        NavigationManager.NavigateTo($"/session/{session.SessionId}");
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage) || isSending)
            return;

        isSending = true;
        try
        {
            var userMessage = newMessage;
            chatMessages.Add(new ChatMessage { IsUser = true, Text = userMessage, Timestamp = DateTime.Now });
            newMessage = string.Empty;

            var botMessage = await ChatService.SendMessageAsync(chatMessages, userMessage);
            botMessage.Timestamp = DateTime.Now;
            chatMessages.Add(botMessage);

            await JSRuntime.InvokeVoidAsync("scrollToBottom", chatContainer);
        }
        catch (Exception ex)
        {
            await LogService.LogError("SendMessage Error", ex.Message);
            chatMessages.Add(new ChatMessage { IsUser = false, Text = "Sorry, something went wrong.", Resources = new List<ChatResource>(), Timestamp = DateTime.Now });
        }
        finally
        {
            isSending = false;
            StateHasChanged();

            await Task.Delay(50);
            try
            {
                await JSRuntime.InvokeVoidAsync("focusElement", chatInputRef);
            }
            catch (JSException jsEx)
            {
                await LogService.LogError("Focus Input Error", jsEx.Message);
            }
        }
    }

    private async Task<TableData<VideoSession>> LoadServerData(TableState state, CancellationToken cancellationToken)
    {
        try
        {
            var filteredSessions = allSessions.AsQueryable();

            filteredSessions = selectedFilter switch
            {
                "Upcoming" => filteredSessions.Where(s => s.ScheduledAt >= DateTime.UtcNow),
                "Past" => filteredSessions.Where(s => s.ScheduledAt < DateTime.UtcNow),
                "All" => filteredSessions,
                _ => filteredSessions
            };

            if (!string.IsNullOrWhiteSpace(searchText))
            {
                filteredSessions = filteredSessions.Where(s =>
                    s.Session.SessionCategory.GetDisplayName().Contains(searchText, StringComparison.OrdinalIgnoreCase) == true);
            }

            filteredSessions = filteredSessions.OrderByDescending(s => s.ScheduledAt);

            var totalItems = filteredSessions.Count();

            var pagedData = filteredSessions
                .Skip(state.Page * state.PageSize)
                .Take(state.PageSize)
                .ToList();

            return new TableData<VideoSession>
            {
                Items = pagedData,
                TotalItems = totalItems
            };
        }
        catch (Exception ex)
        {
            await LogService.LogError("LoadServerData Error", ex.Message);
            Snackbar.Add("Failed to load sessions. Please try again.", Severity.Error);
            return new TableData<VideoSession>
            {
                Items = new List<VideoSession>(),
                TotalItems = 0
            };
        }
    }

    private async Task DownloadResource(string url, string name)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("downloadFile", url, name, DotNetObjectReference.Create(this));
        }
        catch (JSException ex)
        {
            Snackbar.Add($"Failed to download {name}: {ex.Message}", Severity.Error);
        }
    }

    [JSInvokable]
    public void HandleDownloadResult(string error)
    {
        if (error != null)
        {
            Snackbar.Add($"Download failed: {error}", Severity.Error);
        }
        else
        {
            Snackbar.Add("Download started successfully.", Severity.Success);
        }
    }

    private async Task OnFilterChanged(string value)
    {
        selectedFilter = value;
        if (serverTable != null)
            await serverTable.ReloadServerData();
    }

    private async Task OnSearchChanged(string value)
    {
        searchText = value;
        if (serverTable != null)
            await serverTable.ReloadServerData();
    }

    private void ClearChat()
    {
        chatMessages.Clear();
        StateHasChanged();
    }

    private string GetBookingTypeIcon(BookingType type)
    {
        return type switch
        {
            BookingType.SingleSession => Icons.Material.Filled.EventNote,
            BookingType.SessionPack => Icons.Material.Filled.Inventory,
            BookingType.Subscription => Icons.Material.Filled.Subscriptions,
            _ => Icons.Material.Filled.Help
        };
    }

    private Color GetBookingTypeColor(BookingType type)
    {
        return type switch
        {
            BookingType.SingleSession => Color.Secondary,
            BookingType.SessionPack => Color.Info,
            BookingType.Subscription => Color.Success,
            _ => Color.Default
        };
    }

    public async ValueTask DisposeAsync()
    {
        await JSRuntime.InvokeVoidAsync("VideoCall.endCall");
    }
}